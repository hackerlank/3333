// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: pmd.proto

#ifndef PROTOBUF_pmd_2eproto__INCLUDED
#define PROTOBUF_pmd_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace Pmd {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_pmd_2eproto();
void protobuf_AssignDesc_pmd_2eproto();
void protobuf_ShutdownFile_pmd_2eproto();

class GameZoneInfo;
class ServerName;
class ServerInfo;

enum PlatCommand {
  PlatCommand_Null = 0,
  PlatCommand_Logger = 245,
  PlatCommand_Lobby = 246,
  PlatCommand_Push = 247,
  PlatCommand_Gm = 248,
  PlatCommand_Monitor = 249,
  PlatCommand_Login = 250,
  PlatCommand_Forward = 251,
  PlatCommand_Sdk = 252,
  PlatCommand_Chat = 253
};
bool PlatCommand_IsValid(int value);
const PlatCommand PlatCommand_MIN = PlatCommand_Null;
const PlatCommand PlatCommand_MAX = PlatCommand_Chat;
const int PlatCommand_ARRAYSIZE = PlatCommand_MAX + 1;

const ::google::protobuf::EnumDescriptor* PlatCommand_descriptor();
inline const ::std::string& PlatCommand_Name(PlatCommand value) {
  return ::google::protobuf::internal::NameOfEnum(
    PlatCommand_descriptor(), value);
}
inline bool PlatCommand_Parse(
    const ::std::string& name, PlatCommand* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PlatCommand>(
    PlatCommand_descriptor(), name, value);
}
enum HttpReturnCode {
  HttpReturnCode_Null = 0,
  HttpReturnCode_DbError = 2,
  HttpReturnCode_GameZoneListError = 5,
  HttpReturnCode_SignError = 11,
  HttpReturnCode_ServerShutDown = 12,
  HttpReturnCode_JsonSyntaxError = 13,
  HttpReturnCode_JsonMessageError = 14,
  HttpReturnCode_TokenValueError = 15,
  HttpReturnCode_WaiGuaUidError = 16,
  HttpReturnCode_NoGatewaytDown = 17,
  HttpReturnCode_NoSdkServer = 18,
  HttpReturnCode_SdkCheckSignErr = 19,
  HttpReturnCode_Sdk3PartyServerErr = 20,
  HttpReturnCode_ProtobufErr = 21,
  HttpReturnCode_GatewayErr = 22
};
bool HttpReturnCode_IsValid(int value);
const HttpReturnCode HttpReturnCode_MIN = HttpReturnCode_Null;
const HttpReturnCode HttpReturnCode_MAX = HttpReturnCode_GatewayErr;
const int HttpReturnCode_ARRAYSIZE = HttpReturnCode_MAX + 1;

const ::google::protobuf::EnumDescriptor* HttpReturnCode_descriptor();
inline const ::std::string& HttpReturnCode_Name(HttpReturnCode value) {
  return ::google::protobuf::internal::NameOfEnum(
    HttpReturnCode_descriptor(), value);
}
inline bool HttpReturnCode_Parse(
    const ::std::string& name, HttpReturnCode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<HttpReturnCode>(
    HttpReturnCode_descriptor(), name, value);
}
enum TaskType {
  TaskType_Null = 0,
  TaskType_Monitor = 1,
  TaskType_Login = 2,
  TaskType_NameS = 3,
  TaskType_Sdk = 4,
  TaskType_Gm = 5,
  TaskType_Gateway = 6,
  TaskType_GameZone = 7
};
bool TaskType_IsValid(int value);
const TaskType TaskType_MIN = TaskType_Null;
const TaskType TaskType_MAX = TaskType_GameZone;
const int TaskType_ARRAYSIZE = TaskType_MAX + 1;

const ::google::protobuf::EnumDescriptor* TaskType_descriptor();
inline const ::std::string& TaskType_Name(TaskType value) {
  return ::google::protobuf::internal::NameOfEnum(
    TaskType_descriptor(), value);
}
inline bool TaskType_Parse(
    const ::std::string& name, TaskType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TaskType>(
    TaskType_descriptor(), name, value);
}
enum ServerType {
  UNKNOWNSERVER = 0,
  SUPERSERVER = 1,
  LOGINSERVER = 10,
  RECORDSERVER = 11,
  SESSIONSERVER = 20,
  SCENESSERVER = 21,
  GATEWAYSERVER = 22,
  INFOSERVER = 23,
  HTTPSERVER = 24,
  CHANGESERVER = 25,
  USERSERVER = 26,
  BILLSERVER = 27,
  NAMESERVER = 28,
  MONITORSERVER = 29,
  GMSERVER = 30,
  STATERSERVER = 31,
  SOUNDSERVER = 32,
  BILLSERVER_ALIPAY = 33,
  BILLSERVER_JUNKA = 34,
  BILLSERVER_TIANXIATONG = 35,
  BILLSERVER_ZONGYOU = 36,
  BILLSERVER_OFFLINE = 37,
  BILLSERVER_MESSAGE = 38,
  BILLSERVER_ZQB = 39,
  WEBGATESERVER = 40,
  BILLSERVER_BAIDU = 41,
  BILLSERVER_SHUN = 42,
  SDKSERVER = 43,
  LOGGERSERVER = 44,
  UNILIGHT = 45,
  MAX_SERVERTYPE = 46,
  UnknownServer = 0,
  LoginServer = 10,
  GatewayServer = 22,
  InfoServer = 23,
  HttpsServer = 24,
  ChangeServer = 25,
  UserServer = 26,
  BillServer = 27,
  NameServer = 28,
  MonitorServer = 29,
  GmServer = 30,
  StateServer = 31,
  SoundServer = 32,
  WebGateServer = 40,
  SdkServer = 43,
  LoggerServer = 44,
  UniServer = 45
};
bool ServerType_IsValid(int value);
const ServerType ServerType_MIN = UNKNOWNSERVER;
const ServerType ServerType_MAX = MAX_SERVERTYPE;
const int ServerType_ARRAYSIZE = ServerType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ServerType_descriptor();
inline const ::std::string& ServerType_Name(ServerType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ServerType_descriptor(), value);
}
inline bool ServerType_Parse(
    const ::std::string& name, ServerType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ServerType>(
    ServerType_descriptor(), name, value);
}
enum NetType {
  NetType_near = 0,
  NetType_far = 1,
  NetType_CTC = 2,
  NetType_CNC = 3
};
bool NetType_IsValid(int value);
const NetType NetType_MIN = NetType_near;
const NetType NetType_MAX = NetType_CNC;
const int NetType_ARRAYSIZE = NetType_MAX + 1;

const ::google::protobuf::EnumDescriptor* NetType_descriptor();
inline const ::std::string& NetType_Name(NetType value) {
  return ::google::protobuf::internal::NameOfEnum(
    NetType_descriptor(), value);
}
inline bool NetType_Parse(
    const ::std::string& name, NetType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<NetType>(
    NetType_descriptor(), name, value);
}
enum RobotUid {
  RobotUid_begin = 10000,
  RobotUid_end = 20000
};
bool RobotUid_IsValid(int value);
const RobotUid RobotUid_MIN = RobotUid_begin;
const RobotUid RobotUid_MAX = RobotUid_end;
const int RobotUid_ARRAYSIZE = RobotUid_MAX + 1;

const ::google::protobuf::EnumDescriptor* RobotUid_descriptor();
inline const ::std::string& RobotUid_Name(RobotUid value) {
  return ::google::protobuf::internal::NameOfEnum(
    RobotUid_descriptor(), value);
}
inline bool RobotUid_Parse(
    const ::std::string& name, RobotUid* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RobotUid>(
    RobotUid_descriptor(), name, value);
}
// ===================================================================

class GameZoneInfo : public ::google::protobuf::Message {
 public:
  GameZoneInfo();
  virtual ~GameZoneInfo();

  GameZoneInfo(const GameZoneInfo& from);

  inline GameZoneInfo& operator=(const GameZoneInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GameZoneInfo& default_instance();

  void Swap(GameZoneInfo* other);

  // implements Message ----------------------------------------------

  GameZoneInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GameZoneInfo& from);
  void MergeFrom(const GameZoneInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 gameid = 1;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameidFieldNumber = 1;
  inline ::google::protobuf::uint32 gameid() const;
  inline void set_gameid(::google::protobuf::uint32 value);

  // optional uint32 zoneid = 2;
  inline bool has_zoneid() const;
  inline void clear_zoneid();
  static const int kZoneidFieldNumber = 2;
  inline ::google::protobuf::uint32 zoneid() const;
  inline void set_zoneid(::google::protobuf::uint32 value);

  // optional string gamename = 3;
  inline bool has_gamename() const;
  inline void clear_gamename();
  static const int kGamenameFieldNumber = 3;
  inline const ::std::string& gamename() const;
  inline void set_gamename(const ::std::string& value);
  inline void set_gamename(const char* value);
  inline void set_gamename(const char* value, size_t size);
  inline ::std::string* mutable_gamename();
  inline ::std::string* release_gamename();
  inline void set_allocated_gamename(::std::string* gamename);

  // optional string zonename = 4;
  inline bool has_zonename() const;
  inline void clear_zonename();
  static const int kZonenameFieldNumber = 4;
  inline const ::std::string& zonename() const;
  inline void set_zonename(const ::std::string& value);
  inline void set_zonename(const char* value);
  inline void set_zonename(const char* value, size_t size);
  inline ::std::string* mutable_zonename();
  inline ::std::string* release_zonename();
  inline void set_allocated_zonename(::std::string* zonename);

  // optional string mysql = 5;
  inline bool has_mysql() const;
  inline void clear_mysql();
  static const int kMysqlFieldNumber = 5;
  inline const ::std::string& mysql() const;
  inline void set_mysql(const ::std::string& value);
  inline void set_mysql(const char* value);
  inline void set_mysql(const char* value, size_t size);
  inline ::std::string* mutable_mysql();
  inline ::std::string* release_mysql();
  inline void set_allocated_mysql(::std::string* mysql);

  // optional string redis = 6;
  inline bool has_redis() const;
  inline void clear_redis();
  static const int kRedisFieldNumber = 6;
  inline const ::std::string& redis() const;
  inline void set_redis(const ::std::string& value);
  inline void set_redis(const char* value);
  inline void set_redis(const char* value, size_t size);
  inline ::std::string* mutable_redis();
  inline ::std::string* release_redis();
  inline void set_allocated_redis(::std::string* redis);

  // optional string rethink = 7;
  inline bool has_rethink() const;
  inline void clear_rethink();
  static const int kRethinkFieldNumber = 7;
  inline const ::std::string& rethink() const;
  inline void set_rethink(const ::std::string& value);
  inline void set_rethink(const char* value);
  inline void set_rethink(const char* value, size_t size);
  inline ::std::string* mutable_rethink();
  inline ::std::string* release_rethink();
  inline void set_allocated_rethink(::std::string* rethink);

  // optional string mongo = 8;
  inline bool has_mongo() const;
  inline void clear_mongo();
  static const int kMongoFieldNumber = 8;
  inline const ::std::string& mongo() const;
  inline void set_mongo(const ::std::string& value);
  inline void set_mongo(const char* value);
  inline void set_mongo(const char* value, size_t size);
  inline ::std::string* mutable_mongo();
  inline ::std::string* release_mongo();
  inline void set_allocated_mongo(::std::string* mongo);

  // optional uint32 zonestate = 9;
  inline bool has_zonestate() const;
  inline void clear_zonestate();
  static const int kZonestateFieldNumber = 9;
  inline ::google::protobuf::uint32 zonestate() const;
  inline void set_zonestate(::google::protobuf::uint32 value);

  // optional bool separatezoneuid = 10;
  inline bool has_separatezoneuid() const;
  inline void clear_separatezoneuid();
  static const int kSeparatezoneuidFieldNumber = 10;
  inline bool separatezoneuid() const;
  inline void set_separatezoneuid(bool value);

  // optional string lobby = 11;
  inline bool has_lobby() const;
  inline void clear_lobby();
  static const int kLobbyFieldNumber = 11;
  inline const ::std::string& lobby() const;
  inline void set_lobby(const ::std::string& value);
  inline void set_lobby(const char* value);
  inline void set_lobby(const char* value, size_t size);
  inline ::std::string* mutable_lobby();
  inline ::std::string* release_lobby();
  inline void set_allocated_lobby(::std::string* lobby);

  // optional uint32 zonetype = 12;
  inline bool has_zonetype() const;
  inline void clear_zonetype();
  static const int kZonetypeFieldNumber = 12;
  inline ::google::protobuf::uint32 zonetype() const;
  inline void set_zonetype(::google::protobuf::uint32 value);

  // optional string opentime = 13;
  inline bool has_opentime() const;
  inline void clear_opentime();
  static const int kOpentimeFieldNumber = 13;
  inline const ::std::string& opentime() const;
  inline void set_opentime(const ::std::string& value);
  inline void set_opentime(const char* value);
  inline void set_opentime(const char* value, size_t size);
  inline ::std::string* mutable_opentime();
  inline ::std::string* release_opentime();
  inline void set_allocated_opentime(::std::string* opentime);

  // @@protoc_insertion_point(class_scope:Pmd.GameZoneInfo)
 private:
  inline void set_has_gameid();
  inline void clear_has_gameid();
  inline void set_has_zoneid();
  inline void clear_has_zoneid();
  inline void set_has_gamename();
  inline void clear_has_gamename();
  inline void set_has_zonename();
  inline void clear_has_zonename();
  inline void set_has_mysql();
  inline void clear_has_mysql();
  inline void set_has_redis();
  inline void clear_has_redis();
  inline void set_has_rethink();
  inline void clear_has_rethink();
  inline void set_has_mongo();
  inline void clear_has_mongo();
  inline void set_has_zonestate();
  inline void clear_has_zonestate();
  inline void set_has_separatezoneuid();
  inline void clear_has_separatezoneuid();
  inline void set_has_lobby();
  inline void clear_has_lobby();
  inline void set_has_zonetype();
  inline void clear_has_zonetype();
  inline void set_has_opentime();
  inline void clear_has_opentime();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 gameid_;
  ::google::protobuf::uint32 zoneid_;
  ::std::string* gamename_;
  ::std::string* zonename_;
  ::std::string* mysql_;
  ::std::string* redis_;
  ::std::string* rethink_;
  ::std::string* mongo_;
  ::google::protobuf::uint32 zonestate_;
  bool separatezoneuid_;
  ::std::string* lobby_;
  ::std::string* opentime_;
  ::google::protobuf::uint32 zonetype_;
  friend void  protobuf_AddDesc_pmd_2eproto();
  friend void protobuf_AssignDesc_pmd_2eproto();
  friend void protobuf_ShutdownFile_pmd_2eproto();

  void InitAsDefaultInstance();
  static GameZoneInfo* default_instance_;
};
// -------------------------------------------------------------------

class ServerName : public ::google::protobuf::Message {
 public:
  ServerName();
  virtual ~ServerName();

  ServerName(const ServerName& from);

  inline ServerName& operator=(const ServerName& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ServerName& default_instance();

  void Swap(ServerName* other);

  // implements Message ----------------------------------------------

  ServerName* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ServerName& from);
  void MergeFrom(const ServerName& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string Super = 1 [default = "SuperServer"];
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::std::string& super() const;
  inline void set_super(const ::std::string& value);
  inline void set_super(const char* value);
  inline void set_super(const char* value, size_t size);
  inline ::std::string* mutable_super();
  inline ::std::string* release_super();
  inline void set_allocated_super(::std::string* super);

  // optional string Login = 10 [default = "LoginServer"];
  inline bool has_login() const;
  inline void clear_login();
  static const int kLoginFieldNumber = 10;
  inline const ::std::string& login() const;
  inline void set_login(const ::std::string& value);
  inline void set_login(const char* value);
  inline void set_login(const char* value, size_t size);
  inline ::std::string* mutable_login();
  inline ::std::string* release_login();
  inline void set_allocated_login(::std::string* login);

  // optional string Record = 11 [default = "RecordServer"];
  inline bool has_record() const;
  inline void clear_record();
  static const int kRecordFieldNumber = 11;
  inline const ::std::string& record() const;
  inline void set_record(const ::std::string& value);
  inline void set_record(const char* value);
  inline void set_record(const char* value, size_t size);
  inline ::std::string* mutable_record();
  inline ::std::string* release_record();
  inline void set_allocated_record(::std::string* record);

  // optional string Session = 20 [default = "SessionServer"];
  inline bool has_session() const;
  inline void clear_session();
  static const int kSessionFieldNumber = 20;
  inline const ::std::string& session() const;
  inline void set_session(const ::std::string& value);
  inline void set_session(const char* value);
  inline void set_session(const char* value, size_t size);
  inline ::std::string* mutable_session();
  inline ::std::string* release_session();
  inline void set_allocated_session(::std::string* session);

  // optional string Scene = 21 [default = "ScenesServer"];
  inline bool has_scene() const;
  inline void clear_scene();
  static const int kSceneFieldNumber = 21;
  inline const ::std::string& scene() const;
  inline void set_scene(const ::std::string& value);
  inline void set_scene(const char* value);
  inline void set_scene(const char* value, size_t size);
  inline ::std::string* mutable_scene();
  inline ::std::string* release_scene();
  inline void set_allocated_scene(::std::string* scene);

  // optional string Gateway = 22 [default = "GatewayServer"];
  inline bool has_gateway() const;
  inline void clear_gateway();
  static const int kGatewayFieldNumber = 22;
  inline const ::std::string& gateway() const;
  inline void set_gateway(const ::std::string& value);
  inline void set_gateway(const char* value);
  inline void set_gateway(const char* value, size_t size);
  inline ::std::string* mutable_gateway();
  inline ::std::string* release_gateway();
  inline void set_allocated_gateway(::std::string* gateway);

  // optional string Info = 23 [default = "InfoServer"];
  inline bool has_info() const;
  inline void clear_info();
  static const int kInfoFieldNumber = 23;
  inline const ::std::string& info() const;
  inline void set_info(const ::std::string& value);
  inline void set_info(const char* value);
  inline void set_info(const char* value, size_t size);
  inline ::std::string* mutable_info();
  inline ::std::string* release_info();
  inline void set_allocated_info(::std::string* info);

  // optional string Https = 24 [default = "HttpsServer"];
  inline bool has_https() const;
  inline void clear_https();
  static const int kHttpsFieldNumber = 24;
  inline const ::std::string& https() const;
  inline void set_https(const ::std::string& value);
  inline void set_https(const char* value);
  inline void set_https(const char* value, size_t size);
  inline ::std::string* mutable_https();
  inline ::std::string* release_https();
  inline void set_allocated_https(::std::string* https);

  // optional string Change = 25 [default = "ChangeServer"];
  inline bool has_change() const;
  inline void clear_change();
  static const int kChangeFieldNumber = 25;
  inline const ::std::string& change() const;
  inline void set_change(const ::std::string& value);
  inline void set_change(const char* value);
  inline void set_change(const char* value, size_t size);
  inline ::std::string* mutable_change();
  inline ::std::string* release_change();
  inline void set_allocated_change(::std::string* change);

  // optional string User = 26 [default = "UserServer"];
  inline bool has_user() const;
  inline void clear_user();
  static const int kUserFieldNumber = 26;
  inline const ::std::string& user() const;
  inline void set_user(const ::std::string& value);
  inline void set_user(const char* value);
  inline void set_user(const char* value, size_t size);
  inline ::std::string* mutable_user();
  inline ::std::string* release_user();
  inline void set_allocated_user(::std::string* user);

  // optional string Bill = 27 [default = "BillServer"];
  inline bool has_bill() const;
  inline void clear_bill();
  static const int kBillFieldNumber = 27;
  inline const ::std::string& bill() const;
  inline void set_bill(const ::std::string& value);
  inline void set_bill(const char* value);
  inline void set_bill(const char* value, size_t size);
  inline ::std::string* mutable_bill();
  inline ::std::string* release_bill();
  inline void set_allocated_bill(::std::string* bill);

  // optional string Name = 28 [default = "NameServer"];
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 28;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional string Monitor = 29 [default = "MonitorServer"];
  inline bool has_monitor() const;
  inline void clear_monitor();
  static const int kMonitorFieldNumber = 29;
  inline const ::std::string& monitor() const;
  inline void set_monitor(const ::std::string& value);
  inline void set_monitor(const char* value);
  inline void set_monitor(const char* value, size_t size);
  inline ::std::string* mutable_monitor();
  inline ::std::string* release_monitor();
  inline void set_allocated_monitor(::std::string* monitor);

  // optional string GmServer = 30 [default = "GmServer"];
  inline bool has_gmserver() const;
  inline void clear_gmserver();
  static const int kGmServerFieldNumber = 30;
  inline const ::std::string& gmserver() const;
  inline void set_gmserver(const ::std::string& value);
  inline void set_gmserver(const char* value);
  inline void set_gmserver(const char* value, size_t size);
  inline ::std::string* mutable_gmserver();
  inline ::std::string* release_gmserver();
  inline void set_allocated_gmserver(::std::string* gmserver);

  // optional string State = 31 [default = "StateServer"];
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 31;
  inline const ::std::string& state() const;
  inline void set_state(const ::std::string& value);
  inline void set_state(const char* value);
  inline void set_state(const char* value, size_t size);
  inline ::std::string* mutable_state();
  inline ::std::string* release_state();
  inline void set_allocated_state(::std::string* state);

  // optional string Sound = 32 [default = "SoundServer"];
  inline bool has_sound() const;
  inline void clear_sound();
  static const int kSoundFieldNumber = 32;
  inline const ::std::string& sound() const;
  inline void set_sound(const ::std::string& value);
  inline void set_sound(const char* value);
  inline void set_sound(const char* value, size_t size);
  inline ::std::string* mutable_sound();
  inline ::std::string* release_sound();
  inline void set_allocated_sound(::std::string* sound);

  // optional string WebGate = 40 [default = "WebGateServer"];
  inline bool has_webgate() const;
  inline void clear_webgate();
  static const int kWebGateFieldNumber = 40;
  inline const ::std::string& webgate() const;
  inline void set_webgate(const ::std::string& value);
  inline void set_webgate(const char* value);
  inline void set_webgate(const char* value, size_t size);
  inline ::std::string* mutable_webgate();
  inline ::std::string* release_webgate();
  inline void set_allocated_webgate(::std::string* webgate);

  // optional string Sdk = 43 [default = "SdkServer"];
  inline bool has_sdk() const;
  inline void clear_sdk();
  static const int kSdkFieldNumber = 43;
  inline const ::std::string& sdk() const;
  inline void set_sdk(const ::std::string& value);
  inline void set_sdk(const char* value);
  inline void set_sdk(const char* value, size_t size);
  inline ::std::string* mutable_sdk();
  inline ::std::string* release_sdk();
  inline void set_allocated_sdk(::std::string* sdk);

  // optional string Logger = 44 [default = "LoggerServer"];
  inline bool has_logger() const;
  inline void clear_logger();
  static const int kLoggerFieldNumber = 44;
  inline const ::std::string& logger() const;
  inline void set_logger(const ::std::string& value);
  inline void set_logger(const char* value);
  inline void set_logger(const char* value, size_t size);
  inline ::std::string* mutable_logger();
  inline ::std::string* release_logger();
  inline void set_allocated_logger(::std::string* logger);

  // optional string Uni = 45 [default = "UniServer"];
  inline bool has_uni() const;
  inline void clear_uni();
  static const int kUniFieldNumber = 45;
  inline const ::std::string& uni() const;
  inline void set_uni(const ::std::string& value);
  inline void set_uni(const char* value);
  inline void set_uni(const char* value, size_t size);
  inline ::std::string* mutable_uni();
  inline ::std::string* release_uni();
  inline void set_allocated_uni(::std::string* uni);

  // @@protoc_insertion_point(class_scope:Pmd.ServerName)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_login();
  inline void clear_has_login();
  inline void set_has_record();
  inline void clear_has_record();
  inline void set_has_session();
  inline void clear_has_session();
  inline void set_has_scene();
  inline void clear_has_scene();
  inline void set_has_gateway();
  inline void clear_has_gateway();
  inline void set_has_info();
  inline void clear_has_info();
  inline void set_has_https();
  inline void clear_has_https();
  inline void set_has_change();
  inline void clear_has_change();
  inline void set_has_user();
  inline void clear_has_user();
  inline void set_has_bill();
  inline void clear_has_bill();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_monitor();
  inline void clear_has_monitor();
  inline void set_has_gmserver();
  inline void clear_has_gmserver();
  inline void set_has_state();
  inline void clear_has_state();
  inline void set_has_sound();
  inline void clear_has_sound();
  inline void set_has_webgate();
  inline void clear_has_webgate();
  inline void set_has_sdk();
  inline void clear_has_sdk();
  inline void set_has_logger();
  inline void clear_has_logger();
  inline void set_has_uni();
  inline void clear_has_uni();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  static ::std::string* _default_super_;
  ::std::string* super_;
  static ::std::string* _default_login_;
  ::std::string* login_;
  static ::std::string* _default_record_;
  ::std::string* record_;
  static ::std::string* _default_session_;
  ::std::string* session_;
  static ::std::string* _default_scene_;
  ::std::string* scene_;
  static ::std::string* _default_gateway_;
  ::std::string* gateway_;
  static ::std::string* _default_info_;
  ::std::string* info_;
  static ::std::string* _default_https_;
  ::std::string* https_;
  static ::std::string* _default_change_;
  ::std::string* change_;
  static ::std::string* _default_user_;
  ::std::string* user_;
  static ::std::string* _default_bill_;
  ::std::string* bill_;
  static ::std::string* _default_name_;
  ::std::string* name_;
  static ::std::string* _default_monitor_;
  ::std::string* monitor_;
  static ::std::string* _default_gmserver_;
  ::std::string* gmserver_;
  static ::std::string* _default_state_;
  ::std::string* state_;
  static ::std::string* _default_sound_;
  ::std::string* sound_;
  static ::std::string* _default_webgate_;
  ::std::string* webgate_;
  static ::std::string* _default_sdk_;
  ::std::string* sdk_;
  static ::std::string* _default_logger_;
  ::std::string* logger_;
  static ::std::string* _default_uni_;
  ::std::string* uni_;
  friend void  protobuf_AddDesc_pmd_2eproto();
  friend void protobuf_AssignDesc_pmd_2eproto();
  friend void protobuf_ShutdownFile_pmd_2eproto();

  void InitAsDefaultInstance();
  static ServerName* default_instance_;
};
// -------------------------------------------------------------------

class ServerInfo : public ::google::protobuf::Message {
 public:
  ServerInfo();
  virtual ~ServerInfo();

  ServerInfo(const ServerInfo& from);

  inline ServerInfo& operator=(const ServerInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ServerInfo& default_instance();

  void Swap(ServerInfo* other);

  // implements Message ----------------------------------------------

  ServerInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ServerInfo& from);
  void MergeFrom(const ServerInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 zoneid = 1;
  inline bool has_zoneid() const;
  inline void clear_zoneid();
  static const int kZoneidFieldNumber = 1;
  inline ::google::protobuf::uint32 zoneid() const;
  inline void set_zoneid(::google::protobuf::uint32 value);

  // optional uint32 serverid = 2;
  inline bool has_serverid() const;
  inline void clear_serverid();
  static const int kServeridFieldNumber = 2;
  inline ::google::protobuf::uint32 serverid() const;
  inline void set_serverid(::google::protobuf::uint32 value);

  // optional uint32 servertype = 3;
  inline bool has_servertype() const;
  inline void clear_servertype();
  static const int kServertypeFieldNumber = 3;
  inline ::google::protobuf::uint32 servertype() const;
  inline void set_servertype(::google::protobuf::uint32 value);

  // optional uint32 protocol = 4;
  inline bool has_protocol() const;
  inline void clear_protocol();
  static const int kProtocolFieldNumber = 4;
  inline ::google::protobuf::uint32 protocol() const;
  inline void set_protocol(::google::protobuf::uint32 value);

  // optional uint32 buildtime = 5;
  inline bool has_buildtime() const;
  inline void clear_buildtime();
  static const int kBuildtimeFieldNumber = 5;
  inline ::google::protobuf::uint32 buildtime() const;
  inline void set_buildtime(::google::protobuf::uint32 value);

  // optional uint32 svnversion = 6;
  inline bool has_svnversion() const;
  inline void clear_svnversion();
  static const int kSvnversionFieldNumber = 6;
  inline ::google::protobuf::uint32 svnversion() const;
  inline void set_svnversion(::google::protobuf::uint32 value);

  // optional uint32 data1 = 7;
  inline bool has_data1() const;
  inline void clear_data1();
  static const int kData1FieldNumber = 7;
  inline ::google::protobuf::uint32 data1() const;
  inline void set_data1(::google::protobuf::uint32 value);

  // optional uint32 funcion = 8;
  inline bool has_funcion() const;
  inline void clear_funcion();
  static const int kFuncionFieldNumber = 8;
  inline ::google::protobuf::uint32 funcion() const;
  inline void set_funcion(::google::protobuf::uint32 value);

  // optional uint32 reserve0 = 9;
  inline bool has_reserve0() const;
  inline void clear_reserve0();
  static const int kReserve0FieldNumber = 9;
  inline ::google::protobuf::uint32 reserve0() const;
  inline void set_reserve0(::google::protobuf::uint32 value);

  // optional uint32 reserve1 = 10;
  inline bool has_reserve1() const;
  inline void clear_reserve1();
  static const int kReserve1FieldNumber = 10;
  inline ::google::protobuf::uint32 reserve1() const;
  inline void set_reserve1(::google::protobuf::uint32 value);

  // optional uint32 reserve2 = 11;
  inline bool has_reserve2() const;
  inline void clear_reserve2();
  static const int kReserve2FieldNumber = 11;
  inline ::google::protobuf::uint32 reserve2() const;
  inline void set_reserve2(::google::protobuf::uint32 value);

  // optional uint32 reserve3 = 12;
  inline bool has_reserve3() const;
  inline void clear_reserve3();
  static const int kReserve3FieldNumber = 12;
  inline ::google::protobuf::uint32 reserve3() const;
  inline void set_reserve3(::google::protobuf::uint32 value);

  // optional uint32 serverip = 13;
  inline bool has_serverip() const;
  inline void clear_serverip();
  static const int kServeripFieldNumber = 13;
  inline ::google::protobuf::uint32 serverip() const;
  inline void set_serverip(::google::protobuf::uint32 value);

  // optional uint32 usernum = 14;
  inline bool has_usernum() const;
  inline void clear_usernum();
  static const int kUsernumFieldNumber = 14;
  inline ::google::protobuf::uint32 usernum() const;
  inline void set_usernum(::google::protobuf::uint32 value);

  // optional uint32 time = 15;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 15;
  inline ::google::protobuf::uint32 time() const;
  inline void set_time(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Pmd.ServerInfo)
 private:
  inline void set_has_zoneid();
  inline void clear_has_zoneid();
  inline void set_has_serverid();
  inline void clear_has_serverid();
  inline void set_has_servertype();
  inline void clear_has_servertype();
  inline void set_has_protocol();
  inline void clear_has_protocol();
  inline void set_has_buildtime();
  inline void clear_has_buildtime();
  inline void set_has_svnversion();
  inline void clear_has_svnversion();
  inline void set_has_data1();
  inline void clear_has_data1();
  inline void set_has_funcion();
  inline void clear_has_funcion();
  inline void set_has_reserve0();
  inline void clear_has_reserve0();
  inline void set_has_reserve1();
  inline void clear_has_reserve1();
  inline void set_has_reserve2();
  inline void clear_has_reserve2();
  inline void set_has_reserve3();
  inline void clear_has_reserve3();
  inline void set_has_serverip();
  inline void clear_has_serverip();
  inline void set_has_usernum();
  inline void clear_has_usernum();
  inline void set_has_time();
  inline void clear_has_time();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 zoneid_;
  ::google::protobuf::uint32 serverid_;
  ::google::protobuf::uint32 servertype_;
  ::google::protobuf::uint32 protocol_;
  ::google::protobuf::uint32 buildtime_;
  ::google::protobuf::uint32 svnversion_;
  ::google::protobuf::uint32 data1_;
  ::google::protobuf::uint32 funcion_;
  ::google::protobuf::uint32 reserve0_;
  ::google::protobuf::uint32 reserve1_;
  ::google::protobuf::uint32 reserve2_;
  ::google::protobuf::uint32 reserve3_;
  ::google::protobuf::uint32 serverip_;
  ::google::protobuf::uint32 usernum_;
  ::google::protobuf::uint32 time_;
  friend void  protobuf_AddDesc_pmd_2eproto();
  friend void protobuf_AssignDesc_pmd_2eproto();
  friend void protobuf_ShutdownFile_pmd_2eproto();

  void InitAsDefaultInstance();
  static ServerInfo* default_instance_;
};
// ===================================================================


// ===================================================================

// GameZoneInfo

// optional uint32 gameid = 1;
inline bool GameZoneInfo::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GameZoneInfo::set_has_gameid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GameZoneInfo::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GameZoneInfo::clear_gameid() {
  gameid_ = 0u;
  clear_has_gameid();
}
inline ::google::protobuf::uint32 GameZoneInfo::gameid() const {
  // @@protoc_insertion_point(field_get:Pmd.GameZoneInfo.gameid)
  return gameid_;
}
inline void GameZoneInfo::set_gameid(::google::protobuf::uint32 value) {
  set_has_gameid();
  gameid_ = value;
  // @@protoc_insertion_point(field_set:Pmd.GameZoneInfo.gameid)
}

// optional uint32 zoneid = 2;
inline bool GameZoneInfo::has_zoneid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GameZoneInfo::set_has_zoneid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GameZoneInfo::clear_has_zoneid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GameZoneInfo::clear_zoneid() {
  zoneid_ = 0u;
  clear_has_zoneid();
}
inline ::google::protobuf::uint32 GameZoneInfo::zoneid() const {
  // @@protoc_insertion_point(field_get:Pmd.GameZoneInfo.zoneid)
  return zoneid_;
}
inline void GameZoneInfo::set_zoneid(::google::protobuf::uint32 value) {
  set_has_zoneid();
  zoneid_ = value;
  // @@protoc_insertion_point(field_set:Pmd.GameZoneInfo.zoneid)
}

// optional string gamename = 3;
inline bool GameZoneInfo::has_gamename() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GameZoneInfo::set_has_gamename() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GameZoneInfo::clear_has_gamename() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GameZoneInfo::clear_gamename() {
  if (gamename_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    gamename_->clear();
  }
  clear_has_gamename();
}
inline const ::std::string& GameZoneInfo::gamename() const {
  // @@protoc_insertion_point(field_get:Pmd.GameZoneInfo.gamename)
  return *gamename_;
}
inline void GameZoneInfo::set_gamename(const ::std::string& value) {
  set_has_gamename();
  if (gamename_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    gamename_ = new ::std::string;
  }
  gamename_->assign(value);
  // @@protoc_insertion_point(field_set:Pmd.GameZoneInfo.gamename)
}
inline void GameZoneInfo::set_gamename(const char* value) {
  set_has_gamename();
  if (gamename_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    gamename_ = new ::std::string;
  }
  gamename_->assign(value);
  // @@protoc_insertion_point(field_set_char:Pmd.GameZoneInfo.gamename)
}
inline void GameZoneInfo::set_gamename(const char* value, size_t size) {
  set_has_gamename();
  if (gamename_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    gamename_ = new ::std::string;
  }
  gamename_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Pmd.GameZoneInfo.gamename)
}
inline ::std::string* GameZoneInfo::mutable_gamename() {
  set_has_gamename();
  if (gamename_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    gamename_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Pmd.GameZoneInfo.gamename)
  return gamename_;
}
inline ::std::string* GameZoneInfo::release_gamename() {
  clear_has_gamename();
  if (gamename_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = gamename_;
    gamename_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void GameZoneInfo::set_allocated_gamename(::std::string* gamename) {
  if (gamename_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete gamename_;
  }
  if (gamename) {
    set_has_gamename();
    gamename_ = gamename;
  } else {
    clear_has_gamename();
    gamename_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Pmd.GameZoneInfo.gamename)
}

// optional string zonename = 4;
inline bool GameZoneInfo::has_zonename() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GameZoneInfo::set_has_zonename() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GameZoneInfo::clear_has_zonename() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GameZoneInfo::clear_zonename() {
  if (zonename_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    zonename_->clear();
  }
  clear_has_zonename();
}
inline const ::std::string& GameZoneInfo::zonename() const {
  // @@protoc_insertion_point(field_get:Pmd.GameZoneInfo.zonename)
  return *zonename_;
}
inline void GameZoneInfo::set_zonename(const ::std::string& value) {
  set_has_zonename();
  if (zonename_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    zonename_ = new ::std::string;
  }
  zonename_->assign(value);
  // @@protoc_insertion_point(field_set:Pmd.GameZoneInfo.zonename)
}
inline void GameZoneInfo::set_zonename(const char* value) {
  set_has_zonename();
  if (zonename_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    zonename_ = new ::std::string;
  }
  zonename_->assign(value);
  // @@protoc_insertion_point(field_set_char:Pmd.GameZoneInfo.zonename)
}
inline void GameZoneInfo::set_zonename(const char* value, size_t size) {
  set_has_zonename();
  if (zonename_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    zonename_ = new ::std::string;
  }
  zonename_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Pmd.GameZoneInfo.zonename)
}
inline ::std::string* GameZoneInfo::mutable_zonename() {
  set_has_zonename();
  if (zonename_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    zonename_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Pmd.GameZoneInfo.zonename)
  return zonename_;
}
inline ::std::string* GameZoneInfo::release_zonename() {
  clear_has_zonename();
  if (zonename_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = zonename_;
    zonename_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void GameZoneInfo::set_allocated_zonename(::std::string* zonename) {
  if (zonename_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete zonename_;
  }
  if (zonename) {
    set_has_zonename();
    zonename_ = zonename;
  } else {
    clear_has_zonename();
    zonename_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Pmd.GameZoneInfo.zonename)
}

// optional string mysql = 5;
inline bool GameZoneInfo::has_mysql() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GameZoneInfo::set_has_mysql() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GameZoneInfo::clear_has_mysql() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GameZoneInfo::clear_mysql() {
  if (mysql_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mysql_->clear();
  }
  clear_has_mysql();
}
inline const ::std::string& GameZoneInfo::mysql() const {
  // @@protoc_insertion_point(field_get:Pmd.GameZoneInfo.mysql)
  return *mysql_;
}
inline void GameZoneInfo::set_mysql(const ::std::string& value) {
  set_has_mysql();
  if (mysql_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mysql_ = new ::std::string;
  }
  mysql_->assign(value);
  // @@protoc_insertion_point(field_set:Pmd.GameZoneInfo.mysql)
}
inline void GameZoneInfo::set_mysql(const char* value) {
  set_has_mysql();
  if (mysql_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mysql_ = new ::std::string;
  }
  mysql_->assign(value);
  // @@protoc_insertion_point(field_set_char:Pmd.GameZoneInfo.mysql)
}
inline void GameZoneInfo::set_mysql(const char* value, size_t size) {
  set_has_mysql();
  if (mysql_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mysql_ = new ::std::string;
  }
  mysql_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Pmd.GameZoneInfo.mysql)
}
inline ::std::string* GameZoneInfo::mutable_mysql() {
  set_has_mysql();
  if (mysql_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mysql_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Pmd.GameZoneInfo.mysql)
  return mysql_;
}
inline ::std::string* GameZoneInfo::release_mysql() {
  clear_has_mysql();
  if (mysql_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = mysql_;
    mysql_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void GameZoneInfo::set_allocated_mysql(::std::string* mysql) {
  if (mysql_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete mysql_;
  }
  if (mysql) {
    set_has_mysql();
    mysql_ = mysql;
  } else {
    clear_has_mysql();
    mysql_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Pmd.GameZoneInfo.mysql)
}

// optional string redis = 6;
inline bool GameZoneInfo::has_redis() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void GameZoneInfo::set_has_redis() {
  _has_bits_[0] |= 0x00000020u;
}
inline void GameZoneInfo::clear_has_redis() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void GameZoneInfo::clear_redis() {
  if (redis_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    redis_->clear();
  }
  clear_has_redis();
}
inline const ::std::string& GameZoneInfo::redis() const {
  // @@protoc_insertion_point(field_get:Pmd.GameZoneInfo.redis)
  return *redis_;
}
inline void GameZoneInfo::set_redis(const ::std::string& value) {
  set_has_redis();
  if (redis_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    redis_ = new ::std::string;
  }
  redis_->assign(value);
  // @@protoc_insertion_point(field_set:Pmd.GameZoneInfo.redis)
}
inline void GameZoneInfo::set_redis(const char* value) {
  set_has_redis();
  if (redis_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    redis_ = new ::std::string;
  }
  redis_->assign(value);
  // @@protoc_insertion_point(field_set_char:Pmd.GameZoneInfo.redis)
}
inline void GameZoneInfo::set_redis(const char* value, size_t size) {
  set_has_redis();
  if (redis_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    redis_ = new ::std::string;
  }
  redis_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Pmd.GameZoneInfo.redis)
}
inline ::std::string* GameZoneInfo::mutable_redis() {
  set_has_redis();
  if (redis_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    redis_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Pmd.GameZoneInfo.redis)
  return redis_;
}
inline ::std::string* GameZoneInfo::release_redis() {
  clear_has_redis();
  if (redis_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = redis_;
    redis_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void GameZoneInfo::set_allocated_redis(::std::string* redis) {
  if (redis_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete redis_;
  }
  if (redis) {
    set_has_redis();
    redis_ = redis;
  } else {
    clear_has_redis();
    redis_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Pmd.GameZoneInfo.redis)
}

// optional string rethink = 7;
inline bool GameZoneInfo::has_rethink() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void GameZoneInfo::set_has_rethink() {
  _has_bits_[0] |= 0x00000040u;
}
inline void GameZoneInfo::clear_has_rethink() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void GameZoneInfo::clear_rethink() {
  if (rethink_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    rethink_->clear();
  }
  clear_has_rethink();
}
inline const ::std::string& GameZoneInfo::rethink() const {
  // @@protoc_insertion_point(field_get:Pmd.GameZoneInfo.rethink)
  return *rethink_;
}
inline void GameZoneInfo::set_rethink(const ::std::string& value) {
  set_has_rethink();
  if (rethink_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    rethink_ = new ::std::string;
  }
  rethink_->assign(value);
  // @@protoc_insertion_point(field_set:Pmd.GameZoneInfo.rethink)
}
inline void GameZoneInfo::set_rethink(const char* value) {
  set_has_rethink();
  if (rethink_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    rethink_ = new ::std::string;
  }
  rethink_->assign(value);
  // @@protoc_insertion_point(field_set_char:Pmd.GameZoneInfo.rethink)
}
inline void GameZoneInfo::set_rethink(const char* value, size_t size) {
  set_has_rethink();
  if (rethink_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    rethink_ = new ::std::string;
  }
  rethink_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Pmd.GameZoneInfo.rethink)
}
inline ::std::string* GameZoneInfo::mutable_rethink() {
  set_has_rethink();
  if (rethink_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    rethink_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Pmd.GameZoneInfo.rethink)
  return rethink_;
}
inline ::std::string* GameZoneInfo::release_rethink() {
  clear_has_rethink();
  if (rethink_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = rethink_;
    rethink_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void GameZoneInfo::set_allocated_rethink(::std::string* rethink) {
  if (rethink_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete rethink_;
  }
  if (rethink) {
    set_has_rethink();
    rethink_ = rethink;
  } else {
    clear_has_rethink();
    rethink_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Pmd.GameZoneInfo.rethink)
}

// optional string mongo = 8;
inline bool GameZoneInfo::has_mongo() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void GameZoneInfo::set_has_mongo() {
  _has_bits_[0] |= 0x00000080u;
}
inline void GameZoneInfo::clear_has_mongo() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void GameZoneInfo::clear_mongo() {
  if (mongo_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mongo_->clear();
  }
  clear_has_mongo();
}
inline const ::std::string& GameZoneInfo::mongo() const {
  // @@protoc_insertion_point(field_get:Pmd.GameZoneInfo.mongo)
  return *mongo_;
}
inline void GameZoneInfo::set_mongo(const ::std::string& value) {
  set_has_mongo();
  if (mongo_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mongo_ = new ::std::string;
  }
  mongo_->assign(value);
  // @@protoc_insertion_point(field_set:Pmd.GameZoneInfo.mongo)
}
inline void GameZoneInfo::set_mongo(const char* value) {
  set_has_mongo();
  if (mongo_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mongo_ = new ::std::string;
  }
  mongo_->assign(value);
  // @@protoc_insertion_point(field_set_char:Pmd.GameZoneInfo.mongo)
}
inline void GameZoneInfo::set_mongo(const char* value, size_t size) {
  set_has_mongo();
  if (mongo_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mongo_ = new ::std::string;
  }
  mongo_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Pmd.GameZoneInfo.mongo)
}
inline ::std::string* GameZoneInfo::mutable_mongo() {
  set_has_mongo();
  if (mongo_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mongo_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Pmd.GameZoneInfo.mongo)
  return mongo_;
}
inline ::std::string* GameZoneInfo::release_mongo() {
  clear_has_mongo();
  if (mongo_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = mongo_;
    mongo_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void GameZoneInfo::set_allocated_mongo(::std::string* mongo) {
  if (mongo_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete mongo_;
  }
  if (mongo) {
    set_has_mongo();
    mongo_ = mongo;
  } else {
    clear_has_mongo();
    mongo_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Pmd.GameZoneInfo.mongo)
}

// optional uint32 zonestate = 9;
inline bool GameZoneInfo::has_zonestate() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void GameZoneInfo::set_has_zonestate() {
  _has_bits_[0] |= 0x00000100u;
}
inline void GameZoneInfo::clear_has_zonestate() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void GameZoneInfo::clear_zonestate() {
  zonestate_ = 0u;
  clear_has_zonestate();
}
inline ::google::protobuf::uint32 GameZoneInfo::zonestate() const {
  // @@protoc_insertion_point(field_get:Pmd.GameZoneInfo.zonestate)
  return zonestate_;
}
inline void GameZoneInfo::set_zonestate(::google::protobuf::uint32 value) {
  set_has_zonestate();
  zonestate_ = value;
  // @@protoc_insertion_point(field_set:Pmd.GameZoneInfo.zonestate)
}

// optional bool separatezoneuid = 10;
inline bool GameZoneInfo::has_separatezoneuid() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void GameZoneInfo::set_has_separatezoneuid() {
  _has_bits_[0] |= 0x00000200u;
}
inline void GameZoneInfo::clear_has_separatezoneuid() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void GameZoneInfo::clear_separatezoneuid() {
  separatezoneuid_ = false;
  clear_has_separatezoneuid();
}
inline bool GameZoneInfo::separatezoneuid() const {
  // @@protoc_insertion_point(field_get:Pmd.GameZoneInfo.separatezoneuid)
  return separatezoneuid_;
}
inline void GameZoneInfo::set_separatezoneuid(bool value) {
  set_has_separatezoneuid();
  separatezoneuid_ = value;
  // @@protoc_insertion_point(field_set:Pmd.GameZoneInfo.separatezoneuid)
}

// optional string lobby = 11;
inline bool GameZoneInfo::has_lobby() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void GameZoneInfo::set_has_lobby() {
  _has_bits_[0] |= 0x00000400u;
}
inline void GameZoneInfo::clear_has_lobby() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void GameZoneInfo::clear_lobby() {
  if (lobby_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    lobby_->clear();
  }
  clear_has_lobby();
}
inline const ::std::string& GameZoneInfo::lobby() const {
  // @@protoc_insertion_point(field_get:Pmd.GameZoneInfo.lobby)
  return *lobby_;
}
inline void GameZoneInfo::set_lobby(const ::std::string& value) {
  set_has_lobby();
  if (lobby_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    lobby_ = new ::std::string;
  }
  lobby_->assign(value);
  // @@protoc_insertion_point(field_set:Pmd.GameZoneInfo.lobby)
}
inline void GameZoneInfo::set_lobby(const char* value) {
  set_has_lobby();
  if (lobby_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    lobby_ = new ::std::string;
  }
  lobby_->assign(value);
  // @@protoc_insertion_point(field_set_char:Pmd.GameZoneInfo.lobby)
}
inline void GameZoneInfo::set_lobby(const char* value, size_t size) {
  set_has_lobby();
  if (lobby_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    lobby_ = new ::std::string;
  }
  lobby_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Pmd.GameZoneInfo.lobby)
}
inline ::std::string* GameZoneInfo::mutable_lobby() {
  set_has_lobby();
  if (lobby_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    lobby_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Pmd.GameZoneInfo.lobby)
  return lobby_;
}
inline ::std::string* GameZoneInfo::release_lobby() {
  clear_has_lobby();
  if (lobby_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = lobby_;
    lobby_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void GameZoneInfo::set_allocated_lobby(::std::string* lobby) {
  if (lobby_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete lobby_;
  }
  if (lobby) {
    set_has_lobby();
    lobby_ = lobby;
  } else {
    clear_has_lobby();
    lobby_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Pmd.GameZoneInfo.lobby)
}

// optional uint32 zonetype = 12;
inline bool GameZoneInfo::has_zonetype() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void GameZoneInfo::set_has_zonetype() {
  _has_bits_[0] |= 0x00000800u;
}
inline void GameZoneInfo::clear_has_zonetype() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void GameZoneInfo::clear_zonetype() {
  zonetype_ = 0u;
  clear_has_zonetype();
}
inline ::google::protobuf::uint32 GameZoneInfo::zonetype() const {
  // @@protoc_insertion_point(field_get:Pmd.GameZoneInfo.zonetype)
  return zonetype_;
}
inline void GameZoneInfo::set_zonetype(::google::protobuf::uint32 value) {
  set_has_zonetype();
  zonetype_ = value;
  // @@protoc_insertion_point(field_set:Pmd.GameZoneInfo.zonetype)
}

// optional string opentime = 13;
inline bool GameZoneInfo::has_opentime() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void GameZoneInfo::set_has_opentime() {
  _has_bits_[0] |= 0x00001000u;
}
inline void GameZoneInfo::clear_has_opentime() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void GameZoneInfo::clear_opentime() {
  if (opentime_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    opentime_->clear();
  }
  clear_has_opentime();
}
inline const ::std::string& GameZoneInfo::opentime() const {
  // @@protoc_insertion_point(field_get:Pmd.GameZoneInfo.opentime)
  return *opentime_;
}
inline void GameZoneInfo::set_opentime(const ::std::string& value) {
  set_has_opentime();
  if (opentime_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    opentime_ = new ::std::string;
  }
  opentime_->assign(value);
  // @@protoc_insertion_point(field_set:Pmd.GameZoneInfo.opentime)
}
inline void GameZoneInfo::set_opentime(const char* value) {
  set_has_opentime();
  if (opentime_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    opentime_ = new ::std::string;
  }
  opentime_->assign(value);
  // @@protoc_insertion_point(field_set_char:Pmd.GameZoneInfo.opentime)
}
inline void GameZoneInfo::set_opentime(const char* value, size_t size) {
  set_has_opentime();
  if (opentime_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    opentime_ = new ::std::string;
  }
  opentime_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Pmd.GameZoneInfo.opentime)
}
inline ::std::string* GameZoneInfo::mutable_opentime() {
  set_has_opentime();
  if (opentime_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    opentime_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Pmd.GameZoneInfo.opentime)
  return opentime_;
}
inline ::std::string* GameZoneInfo::release_opentime() {
  clear_has_opentime();
  if (opentime_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = opentime_;
    opentime_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void GameZoneInfo::set_allocated_opentime(::std::string* opentime) {
  if (opentime_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete opentime_;
  }
  if (opentime) {
    set_has_opentime();
    opentime_ = opentime;
  } else {
    clear_has_opentime();
    opentime_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Pmd.GameZoneInfo.opentime)
}

// -------------------------------------------------------------------

// ServerName

// optional string Super = 1 [default = "SuperServer"];
inline bool ServerName::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ServerName::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ServerName::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ServerName::clear_super() {
  if (super_ != _default_super_) {
    super_->assign(*_default_super_);
  }
  clear_has_super();
}
inline const ::std::string& ServerName::super() const {
  // @@protoc_insertion_point(field_get:Pmd.ServerName.Super)
  return *super_;
}
inline void ServerName::set_super(const ::std::string& value) {
  set_has_super();
  if (super_ == _default_super_) {
    super_ = new ::std::string;
  }
  super_->assign(value);
  // @@protoc_insertion_point(field_set:Pmd.ServerName.Super)
}
inline void ServerName::set_super(const char* value) {
  set_has_super();
  if (super_ == _default_super_) {
    super_ = new ::std::string;
  }
  super_->assign(value);
  // @@protoc_insertion_point(field_set_char:Pmd.ServerName.Super)
}
inline void ServerName::set_super(const char* value, size_t size) {
  set_has_super();
  if (super_ == _default_super_) {
    super_ = new ::std::string;
  }
  super_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Pmd.ServerName.Super)
}
inline ::std::string* ServerName::mutable_super() {
  set_has_super();
  if (super_ == _default_super_) {
    super_ = new ::std::string(*_default_super_);
  }
  // @@protoc_insertion_point(field_mutable:Pmd.ServerName.Super)
  return super_;
}
inline ::std::string* ServerName::release_super() {
  clear_has_super();
  if (super_ == _default_super_) {
    return NULL;
  } else {
    ::std::string* temp = super_;
    super_ = const_cast< ::std::string*>(_default_super_);
    return temp;
  }
}
inline void ServerName::set_allocated_super(::std::string* super) {
  if (super_ != _default_super_) {
    delete super_;
  }
  if (super) {
    set_has_super();
    super_ = super;
  } else {
    clear_has_super();
    super_ = const_cast< ::std::string*>(_default_super_);
  }
  // @@protoc_insertion_point(field_set_allocated:Pmd.ServerName.Super)
}

// optional string Login = 10 [default = "LoginServer"];
inline bool ServerName::has_login() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ServerName::set_has_login() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ServerName::clear_has_login() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ServerName::clear_login() {
  if (login_ != _default_login_) {
    login_->assign(*_default_login_);
  }
  clear_has_login();
}
inline const ::std::string& ServerName::login() const {
  // @@protoc_insertion_point(field_get:Pmd.ServerName.Login)
  return *login_;
}
inline void ServerName::set_login(const ::std::string& value) {
  set_has_login();
  if (login_ == _default_login_) {
    login_ = new ::std::string;
  }
  login_->assign(value);
  // @@protoc_insertion_point(field_set:Pmd.ServerName.Login)
}
inline void ServerName::set_login(const char* value) {
  set_has_login();
  if (login_ == _default_login_) {
    login_ = new ::std::string;
  }
  login_->assign(value);
  // @@protoc_insertion_point(field_set_char:Pmd.ServerName.Login)
}
inline void ServerName::set_login(const char* value, size_t size) {
  set_has_login();
  if (login_ == _default_login_) {
    login_ = new ::std::string;
  }
  login_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Pmd.ServerName.Login)
}
inline ::std::string* ServerName::mutable_login() {
  set_has_login();
  if (login_ == _default_login_) {
    login_ = new ::std::string(*_default_login_);
  }
  // @@protoc_insertion_point(field_mutable:Pmd.ServerName.Login)
  return login_;
}
inline ::std::string* ServerName::release_login() {
  clear_has_login();
  if (login_ == _default_login_) {
    return NULL;
  } else {
    ::std::string* temp = login_;
    login_ = const_cast< ::std::string*>(_default_login_);
    return temp;
  }
}
inline void ServerName::set_allocated_login(::std::string* login) {
  if (login_ != _default_login_) {
    delete login_;
  }
  if (login) {
    set_has_login();
    login_ = login;
  } else {
    clear_has_login();
    login_ = const_cast< ::std::string*>(_default_login_);
  }
  // @@protoc_insertion_point(field_set_allocated:Pmd.ServerName.Login)
}

// optional string Record = 11 [default = "RecordServer"];
inline bool ServerName::has_record() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ServerName::set_has_record() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ServerName::clear_has_record() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ServerName::clear_record() {
  if (record_ != _default_record_) {
    record_->assign(*_default_record_);
  }
  clear_has_record();
}
inline const ::std::string& ServerName::record() const {
  // @@protoc_insertion_point(field_get:Pmd.ServerName.Record)
  return *record_;
}
inline void ServerName::set_record(const ::std::string& value) {
  set_has_record();
  if (record_ == _default_record_) {
    record_ = new ::std::string;
  }
  record_->assign(value);
  // @@protoc_insertion_point(field_set:Pmd.ServerName.Record)
}
inline void ServerName::set_record(const char* value) {
  set_has_record();
  if (record_ == _default_record_) {
    record_ = new ::std::string;
  }
  record_->assign(value);
  // @@protoc_insertion_point(field_set_char:Pmd.ServerName.Record)
}
inline void ServerName::set_record(const char* value, size_t size) {
  set_has_record();
  if (record_ == _default_record_) {
    record_ = new ::std::string;
  }
  record_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Pmd.ServerName.Record)
}
inline ::std::string* ServerName::mutable_record() {
  set_has_record();
  if (record_ == _default_record_) {
    record_ = new ::std::string(*_default_record_);
  }
  // @@protoc_insertion_point(field_mutable:Pmd.ServerName.Record)
  return record_;
}
inline ::std::string* ServerName::release_record() {
  clear_has_record();
  if (record_ == _default_record_) {
    return NULL;
  } else {
    ::std::string* temp = record_;
    record_ = const_cast< ::std::string*>(_default_record_);
    return temp;
  }
}
inline void ServerName::set_allocated_record(::std::string* record) {
  if (record_ != _default_record_) {
    delete record_;
  }
  if (record) {
    set_has_record();
    record_ = record;
  } else {
    clear_has_record();
    record_ = const_cast< ::std::string*>(_default_record_);
  }
  // @@protoc_insertion_point(field_set_allocated:Pmd.ServerName.Record)
}

// optional string Session = 20 [default = "SessionServer"];
inline bool ServerName::has_session() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ServerName::set_has_session() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ServerName::clear_has_session() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ServerName::clear_session() {
  if (session_ != _default_session_) {
    session_->assign(*_default_session_);
  }
  clear_has_session();
}
inline const ::std::string& ServerName::session() const {
  // @@protoc_insertion_point(field_get:Pmd.ServerName.Session)
  return *session_;
}
inline void ServerName::set_session(const ::std::string& value) {
  set_has_session();
  if (session_ == _default_session_) {
    session_ = new ::std::string;
  }
  session_->assign(value);
  // @@protoc_insertion_point(field_set:Pmd.ServerName.Session)
}
inline void ServerName::set_session(const char* value) {
  set_has_session();
  if (session_ == _default_session_) {
    session_ = new ::std::string;
  }
  session_->assign(value);
  // @@protoc_insertion_point(field_set_char:Pmd.ServerName.Session)
}
inline void ServerName::set_session(const char* value, size_t size) {
  set_has_session();
  if (session_ == _default_session_) {
    session_ = new ::std::string;
  }
  session_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Pmd.ServerName.Session)
}
inline ::std::string* ServerName::mutable_session() {
  set_has_session();
  if (session_ == _default_session_) {
    session_ = new ::std::string(*_default_session_);
  }
  // @@protoc_insertion_point(field_mutable:Pmd.ServerName.Session)
  return session_;
}
inline ::std::string* ServerName::release_session() {
  clear_has_session();
  if (session_ == _default_session_) {
    return NULL;
  } else {
    ::std::string* temp = session_;
    session_ = const_cast< ::std::string*>(_default_session_);
    return temp;
  }
}
inline void ServerName::set_allocated_session(::std::string* session) {
  if (session_ != _default_session_) {
    delete session_;
  }
  if (session) {
    set_has_session();
    session_ = session;
  } else {
    clear_has_session();
    session_ = const_cast< ::std::string*>(_default_session_);
  }
  // @@protoc_insertion_point(field_set_allocated:Pmd.ServerName.Session)
}

// optional string Scene = 21 [default = "ScenesServer"];
inline bool ServerName::has_scene() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ServerName::set_has_scene() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ServerName::clear_has_scene() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ServerName::clear_scene() {
  if (scene_ != _default_scene_) {
    scene_->assign(*_default_scene_);
  }
  clear_has_scene();
}
inline const ::std::string& ServerName::scene() const {
  // @@protoc_insertion_point(field_get:Pmd.ServerName.Scene)
  return *scene_;
}
inline void ServerName::set_scene(const ::std::string& value) {
  set_has_scene();
  if (scene_ == _default_scene_) {
    scene_ = new ::std::string;
  }
  scene_->assign(value);
  // @@protoc_insertion_point(field_set:Pmd.ServerName.Scene)
}
inline void ServerName::set_scene(const char* value) {
  set_has_scene();
  if (scene_ == _default_scene_) {
    scene_ = new ::std::string;
  }
  scene_->assign(value);
  // @@protoc_insertion_point(field_set_char:Pmd.ServerName.Scene)
}
inline void ServerName::set_scene(const char* value, size_t size) {
  set_has_scene();
  if (scene_ == _default_scene_) {
    scene_ = new ::std::string;
  }
  scene_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Pmd.ServerName.Scene)
}
inline ::std::string* ServerName::mutable_scene() {
  set_has_scene();
  if (scene_ == _default_scene_) {
    scene_ = new ::std::string(*_default_scene_);
  }
  // @@protoc_insertion_point(field_mutable:Pmd.ServerName.Scene)
  return scene_;
}
inline ::std::string* ServerName::release_scene() {
  clear_has_scene();
  if (scene_ == _default_scene_) {
    return NULL;
  } else {
    ::std::string* temp = scene_;
    scene_ = const_cast< ::std::string*>(_default_scene_);
    return temp;
  }
}
inline void ServerName::set_allocated_scene(::std::string* scene) {
  if (scene_ != _default_scene_) {
    delete scene_;
  }
  if (scene) {
    set_has_scene();
    scene_ = scene;
  } else {
    clear_has_scene();
    scene_ = const_cast< ::std::string*>(_default_scene_);
  }
  // @@protoc_insertion_point(field_set_allocated:Pmd.ServerName.Scene)
}

// optional string Gateway = 22 [default = "GatewayServer"];
inline bool ServerName::has_gateway() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ServerName::set_has_gateway() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ServerName::clear_has_gateway() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ServerName::clear_gateway() {
  if (gateway_ != _default_gateway_) {
    gateway_->assign(*_default_gateway_);
  }
  clear_has_gateway();
}
inline const ::std::string& ServerName::gateway() const {
  // @@protoc_insertion_point(field_get:Pmd.ServerName.Gateway)
  return *gateway_;
}
inline void ServerName::set_gateway(const ::std::string& value) {
  set_has_gateway();
  if (gateway_ == _default_gateway_) {
    gateway_ = new ::std::string;
  }
  gateway_->assign(value);
  // @@protoc_insertion_point(field_set:Pmd.ServerName.Gateway)
}
inline void ServerName::set_gateway(const char* value) {
  set_has_gateway();
  if (gateway_ == _default_gateway_) {
    gateway_ = new ::std::string;
  }
  gateway_->assign(value);
  // @@protoc_insertion_point(field_set_char:Pmd.ServerName.Gateway)
}
inline void ServerName::set_gateway(const char* value, size_t size) {
  set_has_gateway();
  if (gateway_ == _default_gateway_) {
    gateway_ = new ::std::string;
  }
  gateway_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Pmd.ServerName.Gateway)
}
inline ::std::string* ServerName::mutable_gateway() {
  set_has_gateway();
  if (gateway_ == _default_gateway_) {
    gateway_ = new ::std::string(*_default_gateway_);
  }
  // @@protoc_insertion_point(field_mutable:Pmd.ServerName.Gateway)
  return gateway_;
}
inline ::std::string* ServerName::release_gateway() {
  clear_has_gateway();
  if (gateway_ == _default_gateway_) {
    return NULL;
  } else {
    ::std::string* temp = gateway_;
    gateway_ = const_cast< ::std::string*>(_default_gateway_);
    return temp;
  }
}
inline void ServerName::set_allocated_gateway(::std::string* gateway) {
  if (gateway_ != _default_gateway_) {
    delete gateway_;
  }
  if (gateway) {
    set_has_gateway();
    gateway_ = gateway;
  } else {
    clear_has_gateway();
    gateway_ = const_cast< ::std::string*>(_default_gateway_);
  }
  // @@protoc_insertion_point(field_set_allocated:Pmd.ServerName.Gateway)
}

// optional string Info = 23 [default = "InfoServer"];
inline bool ServerName::has_info() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ServerName::set_has_info() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ServerName::clear_has_info() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ServerName::clear_info() {
  if (info_ != _default_info_) {
    info_->assign(*_default_info_);
  }
  clear_has_info();
}
inline const ::std::string& ServerName::info() const {
  // @@protoc_insertion_point(field_get:Pmd.ServerName.Info)
  return *info_;
}
inline void ServerName::set_info(const ::std::string& value) {
  set_has_info();
  if (info_ == _default_info_) {
    info_ = new ::std::string;
  }
  info_->assign(value);
  // @@protoc_insertion_point(field_set:Pmd.ServerName.Info)
}
inline void ServerName::set_info(const char* value) {
  set_has_info();
  if (info_ == _default_info_) {
    info_ = new ::std::string;
  }
  info_->assign(value);
  // @@protoc_insertion_point(field_set_char:Pmd.ServerName.Info)
}
inline void ServerName::set_info(const char* value, size_t size) {
  set_has_info();
  if (info_ == _default_info_) {
    info_ = new ::std::string;
  }
  info_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Pmd.ServerName.Info)
}
inline ::std::string* ServerName::mutable_info() {
  set_has_info();
  if (info_ == _default_info_) {
    info_ = new ::std::string(*_default_info_);
  }
  // @@protoc_insertion_point(field_mutable:Pmd.ServerName.Info)
  return info_;
}
inline ::std::string* ServerName::release_info() {
  clear_has_info();
  if (info_ == _default_info_) {
    return NULL;
  } else {
    ::std::string* temp = info_;
    info_ = const_cast< ::std::string*>(_default_info_);
    return temp;
  }
}
inline void ServerName::set_allocated_info(::std::string* info) {
  if (info_ != _default_info_) {
    delete info_;
  }
  if (info) {
    set_has_info();
    info_ = info;
  } else {
    clear_has_info();
    info_ = const_cast< ::std::string*>(_default_info_);
  }
  // @@protoc_insertion_point(field_set_allocated:Pmd.ServerName.Info)
}

// optional string Https = 24 [default = "HttpsServer"];
inline bool ServerName::has_https() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ServerName::set_has_https() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ServerName::clear_has_https() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ServerName::clear_https() {
  if (https_ != _default_https_) {
    https_->assign(*_default_https_);
  }
  clear_has_https();
}
inline const ::std::string& ServerName::https() const {
  // @@protoc_insertion_point(field_get:Pmd.ServerName.Https)
  return *https_;
}
inline void ServerName::set_https(const ::std::string& value) {
  set_has_https();
  if (https_ == _default_https_) {
    https_ = new ::std::string;
  }
  https_->assign(value);
  // @@protoc_insertion_point(field_set:Pmd.ServerName.Https)
}
inline void ServerName::set_https(const char* value) {
  set_has_https();
  if (https_ == _default_https_) {
    https_ = new ::std::string;
  }
  https_->assign(value);
  // @@protoc_insertion_point(field_set_char:Pmd.ServerName.Https)
}
inline void ServerName::set_https(const char* value, size_t size) {
  set_has_https();
  if (https_ == _default_https_) {
    https_ = new ::std::string;
  }
  https_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Pmd.ServerName.Https)
}
inline ::std::string* ServerName::mutable_https() {
  set_has_https();
  if (https_ == _default_https_) {
    https_ = new ::std::string(*_default_https_);
  }
  // @@protoc_insertion_point(field_mutable:Pmd.ServerName.Https)
  return https_;
}
inline ::std::string* ServerName::release_https() {
  clear_has_https();
  if (https_ == _default_https_) {
    return NULL;
  } else {
    ::std::string* temp = https_;
    https_ = const_cast< ::std::string*>(_default_https_);
    return temp;
  }
}
inline void ServerName::set_allocated_https(::std::string* https) {
  if (https_ != _default_https_) {
    delete https_;
  }
  if (https) {
    set_has_https();
    https_ = https;
  } else {
    clear_has_https();
    https_ = const_cast< ::std::string*>(_default_https_);
  }
  // @@protoc_insertion_point(field_set_allocated:Pmd.ServerName.Https)
}

// optional string Change = 25 [default = "ChangeServer"];
inline bool ServerName::has_change() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ServerName::set_has_change() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ServerName::clear_has_change() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ServerName::clear_change() {
  if (change_ != _default_change_) {
    change_->assign(*_default_change_);
  }
  clear_has_change();
}
inline const ::std::string& ServerName::change() const {
  // @@protoc_insertion_point(field_get:Pmd.ServerName.Change)
  return *change_;
}
inline void ServerName::set_change(const ::std::string& value) {
  set_has_change();
  if (change_ == _default_change_) {
    change_ = new ::std::string;
  }
  change_->assign(value);
  // @@protoc_insertion_point(field_set:Pmd.ServerName.Change)
}
inline void ServerName::set_change(const char* value) {
  set_has_change();
  if (change_ == _default_change_) {
    change_ = new ::std::string;
  }
  change_->assign(value);
  // @@protoc_insertion_point(field_set_char:Pmd.ServerName.Change)
}
inline void ServerName::set_change(const char* value, size_t size) {
  set_has_change();
  if (change_ == _default_change_) {
    change_ = new ::std::string;
  }
  change_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Pmd.ServerName.Change)
}
inline ::std::string* ServerName::mutable_change() {
  set_has_change();
  if (change_ == _default_change_) {
    change_ = new ::std::string(*_default_change_);
  }
  // @@protoc_insertion_point(field_mutable:Pmd.ServerName.Change)
  return change_;
}
inline ::std::string* ServerName::release_change() {
  clear_has_change();
  if (change_ == _default_change_) {
    return NULL;
  } else {
    ::std::string* temp = change_;
    change_ = const_cast< ::std::string*>(_default_change_);
    return temp;
  }
}
inline void ServerName::set_allocated_change(::std::string* change) {
  if (change_ != _default_change_) {
    delete change_;
  }
  if (change) {
    set_has_change();
    change_ = change;
  } else {
    clear_has_change();
    change_ = const_cast< ::std::string*>(_default_change_);
  }
  // @@protoc_insertion_point(field_set_allocated:Pmd.ServerName.Change)
}

// optional string User = 26 [default = "UserServer"];
inline bool ServerName::has_user() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void ServerName::set_has_user() {
  _has_bits_[0] |= 0x00000200u;
}
inline void ServerName::clear_has_user() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void ServerName::clear_user() {
  if (user_ != _default_user_) {
    user_->assign(*_default_user_);
  }
  clear_has_user();
}
inline const ::std::string& ServerName::user() const {
  // @@protoc_insertion_point(field_get:Pmd.ServerName.User)
  return *user_;
}
inline void ServerName::set_user(const ::std::string& value) {
  set_has_user();
  if (user_ == _default_user_) {
    user_ = new ::std::string;
  }
  user_->assign(value);
  // @@protoc_insertion_point(field_set:Pmd.ServerName.User)
}
inline void ServerName::set_user(const char* value) {
  set_has_user();
  if (user_ == _default_user_) {
    user_ = new ::std::string;
  }
  user_->assign(value);
  // @@protoc_insertion_point(field_set_char:Pmd.ServerName.User)
}
inline void ServerName::set_user(const char* value, size_t size) {
  set_has_user();
  if (user_ == _default_user_) {
    user_ = new ::std::string;
  }
  user_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Pmd.ServerName.User)
}
inline ::std::string* ServerName::mutable_user() {
  set_has_user();
  if (user_ == _default_user_) {
    user_ = new ::std::string(*_default_user_);
  }
  // @@protoc_insertion_point(field_mutable:Pmd.ServerName.User)
  return user_;
}
inline ::std::string* ServerName::release_user() {
  clear_has_user();
  if (user_ == _default_user_) {
    return NULL;
  } else {
    ::std::string* temp = user_;
    user_ = const_cast< ::std::string*>(_default_user_);
    return temp;
  }
}
inline void ServerName::set_allocated_user(::std::string* user) {
  if (user_ != _default_user_) {
    delete user_;
  }
  if (user) {
    set_has_user();
    user_ = user;
  } else {
    clear_has_user();
    user_ = const_cast< ::std::string*>(_default_user_);
  }
  // @@protoc_insertion_point(field_set_allocated:Pmd.ServerName.User)
}

// optional string Bill = 27 [default = "BillServer"];
inline bool ServerName::has_bill() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void ServerName::set_has_bill() {
  _has_bits_[0] |= 0x00000400u;
}
inline void ServerName::clear_has_bill() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void ServerName::clear_bill() {
  if (bill_ != _default_bill_) {
    bill_->assign(*_default_bill_);
  }
  clear_has_bill();
}
inline const ::std::string& ServerName::bill() const {
  // @@protoc_insertion_point(field_get:Pmd.ServerName.Bill)
  return *bill_;
}
inline void ServerName::set_bill(const ::std::string& value) {
  set_has_bill();
  if (bill_ == _default_bill_) {
    bill_ = new ::std::string;
  }
  bill_->assign(value);
  // @@protoc_insertion_point(field_set:Pmd.ServerName.Bill)
}
inline void ServerName::set_bill(const char* value) {
  set_has_bill();
  if (bill_ == _default_bill_) {
    bill_ = new ::std::string;
  }
  bill_->assign(value);
  // @@protoc_insertion_point(field_set_char:Pmd.ServerName.Bill)
}
inline void ServerName::set_bill(const char* value, size_t size) {
  set_has_bill();
  if (bill_ == _default_bill_) {
    bill_ = new ::std::string;
  }
  bill_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Pmd.ServerName.Bill)
}
inline ::std::string* ServerName::mutable_bill() {
  set_has_bill();
  if (bill_ == _default_bill_) {
    bill_ = new ::std::string(*_default_bill_);
  }
  // @@protoc_insertion_point(field_mutable:Pmd.ServerName.Bill)
  return bill_;
}
inline ::std::string* ServerName::release_bill() {
  clear_has_bill();
  if (bill_ == _default_bill_) {
    return NULL;
  } else {
    ::std::string* temp = bill_;
    bill_ = const_cast< ::std::string*>(_default_bill_);
    return temp;
  }
}
inline void ServerName::set_allocated_bill(::std::string* bill) {
  if (bill_ != _default_bill_) {
    delete bill_;
  }
  if (bill) {
    set_has_bill();
    bill_ = bill;
  } else {
    clear_has_bill();
    bill_ = const_cast< ::std::string*>(_default_bill_);
  }
  // @@protoc_insertion_point(field_set_allocated:Pmd.ServerName.Bill)
}

// optional string Name = 28 [default = "NameServer"];
inline bool ServerName::has_name() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void ServerName::set_has_name() {
  _has_bits_[0] |= 0x00000800u;
}
inline void ServerName::clear_has_name() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void ServerName::clear_name() {
  if (name_ != _default_name_) {
    name_->assign(*_default_name_);
  }
  clear_has_name();
}
inline const ::std::string& ServerName::name() const {
  // @@protoc_insertion_point(field_get:Pmd.ServerName.Name)
  return *name_;
}
inline void ServerName::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == _default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:Pmd.ServerName.Name)
}
inline void ServerName::set_name(const char* value) {
  set_has_name();
  if (name_ == _default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:Pmd.ServerName.Name)
}
inline void ServerName::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == _default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Pmd.ServerName.Name)
}
inline ::std::string* ServerName::mutable_name() {
  set_has_name();
  if (name_ == _default_name_) {
    name_ = new ::std::string(*_default_name_);
  }
  // @@protoc_insertion_point(field_mutable:Pmd.ServerName.Name)
  return name_;
}
inline ::std::string* ServerName::release_name() {
  clear_has_name();
  if (name_ == _default_name_) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(_default_name_);
    return temp;
  }
}
inline void ServerName::set_allocated_name(::std::string* name) {
  if (name_ != _default_name_) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(_default_name_);
  }
  // @@protoc_insertion_point(field_set_allocated:Pmd.ServerName.Name)
}

// optional string Monitor = 29 [default = "MonitorServer"];
inline bool ServerName::has_monitor() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void ServerName::set_has_monitor() {
  _has_bits_[0] |= 0x00001000u;
}
inline void ServerName::clear_has_monitor() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void ServerName::clear_monitor() {
  if (monitor_ != _default_monitor_) {
    monitor_->assign(*_default_monitor_);
  }
  clear_has_monitor();
}
inline const ::std::string& ServerName::monitor() const {
  // @@protoc_insertion_point(field_get:Pmd.ServerName.Monitor)
  return *monitor_;
}
inline void ServerName::set_monitor(const ::std::string& value) {
  set_has_monitor();
  if (monitor_ == _default_monitor_) {
    monitor_ = new ::std::string;
  }
  monitor_->assign(value);
  // @@protoc_insertion_point(field_set:Pmd.ServerName.Monitor)
}
inline void ServerName::set_monitor(const char* value) {
  set_has_monitor();
  if (monitor_ == _default_monitor_) {
    monitor_ = new ::std::string;
  }
  monitor_->assign(value);
  // @@protoc_insertion_point(field_set_char:Pmd.ServerName.Monitor)
}
inline void ServerName::set_monitor(const char* value, size_t size) {
  set_has_monitor();
  if (monitor_ == _default_monitor_) {
    monitor_ = new ::std::string;
  }
  monitor_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Pmd.ServerName.Monitor)
}
inline ::std::string* ServerName::mutable_monitor() {
  set_has_monitor();
  if (monitor_ == _default_monitor_) {
    monitor_ = new ::std::string(*_default_monitor_);
  }
  // @@protoc_insertion_point(field_mutable:Pmd.ServerName.Monitor)
  return monitor_;
}
inline ::std::string* ServerName::release_monitor() {
  clear_has_monitor();
  if (monitor_ == _default_monitor_) {
    return NULL;
  } else {
    ::std::string* temp = monitor_;
    monitor_ = const_cast< ::std::string*>(_default_monitor_);
    return temp;
  }
}
inline void ServerName::set_allocated_monitor(::std::string* monitor) {
  if (monitor_ != _default_monitor_) {
    delete monitor_;
  }
  if (monitor) {
    set_has_monitor();
    monitor_ = monitor;
  } else {
    clear_has_monitor();
    monitor_ = const_cast< ::std::string*>(_default_monitor_);
  }
  // @@protoc_insertion_point(field_set_allocated:Pmd.ServerName.Monitor)
}

// optional string GmServer = 30 [default = "GmServer"];
inline bool ServerName::has_gmserver() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void ServerName::set_has_gmserver() {
  _has_bits_[0] |= 0x00002000u;
}
inline void ServerName::clear_has_gmserver() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void ServerName::clear_gmserver() {
  if (gmserver_ != _default_gmserver_) {
    gmserver_->assign(*_default_gmserver_);
  }
  clear_has_gmserver();
}
inline const ::std::string& ServerName::gmserver() const {
  // @@protoc_insertion_point(field_get:Pmd.ServerName.GmServer)
  return *gmserver_;
}
inline void ServerName::set_gmserver(const ::std::string& value) {
  set_has_gmserver();
  if (gmserver_ == _default_gmserver_) {
    gmserver_ = new ::std::string;
  }
  gmserver_->assign(value);
  // @@protoc_insertion_point(field_set:Pmd.ServerName.GmServer)
}
inline void ServerName::set_gmserver(const char* value) {
  set_has_gmserver();
  if (gmserver_ == _default_gmserver_) {
    gmserver_ = new ::std::string;
  }
  gmserver_->assign(value);
  // @@protoc_insertion_point(field_set_char:Pmd.ServerName.GmServer)
}
inline void ServerName::set_gmserver(const char* value, size_t size) {
  set_has_gmserver();
  if (gmserver_ == _default_gmserver_) {
    gmserver_ = new ::std::string;
  }
  gmserver_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Pmd.ServerName.GmServer)
}
inline ::std::string* ServerName::mutable_gmserver() {
  set_has_gmserver();
  if (gmserver_ == _default_gmserver_) {
    gmserver_ = new ::std::string(*_default_gmserver_);
  }
  // @@protoc_insertion_point(field_mutable:Pmd.ServerName.GmServer)
  return gmserver_;
}
inline ::std::string* ServerName::release_gmserver() {
  clear_has_gmserver();
  if (gmserver_ == _default_gmserver_) {
    return NULL;
  } else {
    ::std::string* temp = gmserver_;
    gmserver_ = const_cast< ::std::string*>(_default_gmserver_);
    return temp;
  }
}
inline void ServerName::set_allocated_gmserver(::std::string* gmserver) {
  if (gmserver_ != _default_gmserver_) {
    delete gmserver_;
  }
  if (gmserver) {
    set_has_gmserver();
    gmserver_ = gmserver;
  } else {
    clear_has_gmserver();
    gmserver_ = const_cast< ::std::string*>(_default_gmserver_);
  }
  // @@protoc_insertion_point(field_set_allocated:Pmd.ServerName.GmServer)
}

// optional string State = 31 [default = "StateServer"];
inline bool ServerName::has_state() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void ServerName::set_has_state() {
  _has_bits_[0] |= 0x00004000u;
}
inline void ServerName::clear_has_state() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void ServerName::clear_state() {
  if (state_ != _default_state_) {
    state_->assign(*_default_state_);
  }
  clear_has_state();
}
inline const ::std::string& ServerName::state() const {
  // @@protoc_insertion_point(field_get:Pmd.ServerName.State)
  return *state_;
}
inline void ServerName::set_state(const ::std::string& value) {
  set_has_state();
  if (state_ == _default_state_) {
    state_ = new ::std::string;
  }
  state_->assign(value);
  // @@protoc_insertion_point(field_set:Pmd.ServerName.State)
}
inline void ServerName::set_state(const char* value) {
  set_has_state();
  if (state_ == _default_state_) {
    state_ = new ::std::string;
  }
  state_->assign(value);
  // @@protoc_insertion_point(field_set_char:Pmd.ServerName.State)
}
inline void ServerName::set_state(const char* value, size_t size) {
  set_has_state();
  if (state_ == _default_state_) {
    state_ = new ::std::string;
  }
  state_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Pmd.ServerName.State)
}
inline ::std::string* ServerName::mutable_state() {
  set_has_state();
  if (state_ == _default_state_) {
    state_ = new ::std::string(*_default_state_);
  }
  // @@protoc_insertion_point(field_mutable:Pmd.ServerName.State)
  return state_;
}
inline ::std::string* ServerName::release_state() {
  clear_has_state();
  if (state_ == _default_state_) {
    return NULL;
  } else {
    ::std::string* temp = state_;
    state_ = const_cast< ::std::string*>(_default_state_);
    return temp;
  }
}
inline void ServerName::set_allocated_state(::std::string* state) {
  if (state_ != _default_state_) {
    delete state_;
  }
  if (state) {
    set_has_state();
    state_ = state;
  } else {
    clear_has_state();
    state_ = const_cast< ::std::string*>(_default_state_);
  }
  // @@protoc_insertion_point(field_set_allocated:Pmd.ServerName.State)
}

// optional string Sound = 32 [default = "SoundServer"];
inline bool ServerName::has_sound() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void ServerName::set_has_sound() {
  _has_bits_[0] |= 0x00008000u;
}
inline void ServerName::clear_has_sound() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void ServerName::clear_sound() {
  if (sound_ != _default_sound_) {
    sound_->assign(*_default_sound_);
  }
  clear_has_sound();
}
inline const ::std::string& ServerName::sound() const {
  // @@protoc_insertion_point(field_get:Pmd.ServerName.Sound)
  return *sound_;
}
inline void ServerName::set_sound(const ::std::string& value) {
  set_has_sound();
  if (sound_ == _default_sound_) {
    sound_ = new ::std::string;
  }
  sound_->assign(value);
  // @@protoc_insertion_point(field_set:Pmd.ServerName.Sound)
}
inline void ServerName::set_sound(const char* value) {
  set_has_sound();
  if (sound_ == _default_sound_) {
    sound_ = new ::std::string;
  }
  sound_->assign(value);
  // @@protoc_insertion_point(field_set_char:Pmd.ServerName.Sound)
}
inline void ServerName::set_sound(const char* value, size_t size) {
  set_has_sound();
  if (sound_ == _default_sound_) {
    sound_ = new ::std::string;
  }
  sound_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Pmd.ServerName.Sound)
}
inline ::std::string* ServerName::mutable_sound() {
  set_has_sound();
  if (sound_ == _default_sound_) {
    sound_ = new ::std::string(*_default_sound_);
  }
  // @@protoc_insertion_point(field_mutable:Pmd.ServerName.Sound)
  return sound_;
}
inline ::std::string* ServerName::release_sound() {
  clear_has_sound();
  if (sound_ == _default_sound_) {
    return NULL;
  } else {
    ::std::string* temp = sound_;
    sound_ = const_cast< ::std::string*>(_default_sound_);
    return temp;
  }
}
inline void ServerName::set_allocated_sound(::std::string* sound) {
  if (sound_ != _default_sound_) {
    delete sound_;
  }
  if (sound) {
    set_has_sound();
    sound_ = sound;
  } else {
    clear_has_sound();
    sound_ = const_cast< ::std::string*>(_default_sound_);
  }
  // @@protoc_insertion_point(field_set_allocated:Pmd.ServerName.Sound)
}

// optional string WebGate = 40 [default = "WebGateServer"];
inline bool ServerName::has_webgate() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void ServerName::set_has_webgate() {
  _has_bits_[0] |= 0x00010000u;
}
inline void ServerName::clear_has_webgate() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void ServerName::clear_webgate() {
  if (webgate_ != _default_webgate_) {
    webgate_->assign(*_default_webgate_);
  }
  clear_has_webgate();
}
inline const ::std::string& ServerName::webgate() const {
  // @@protoc_insertion_point(field_get:Pmd.ServerName.WebGate)
  return *webgate_;
}
inline void ServerName::set_webgate(const ::std::string& value) {
  set_has_webgate();
  if (webgate_ == _default_webgate_) {
    webgate_ = new ::std::string;
  }
  webgate_->assign(value);
  // @@protoc_insertion_point(field_set:Pmd.ServerName.WebGate)
}
inline void ServerName::set_webgate(const char* value) {
  set_has_webgate();
  if (webgate_ == _default_webgate_) {
    webgate_ = new ::std::string;
  }
  webgate_->assign(value);
  // @@protoc_insertion_point(field_set_char:Pmd.ServerName.WebGate)
}
inline void ServerName::set_webgate(const char* value, size_t size) {
  set_has_webgate();
  if (webgate_ == _default_webgate_) {
    webgate_ = new ::std::string;
  }
  webgate_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Pmd.ServerName.WebGate)
}
inline ::std::string* ServerName::mutable_webgate() {
  set_has_webgate();
  if (webgate_ == _default_webgate_) {
    webgate_ = new ::std::string(*_default_webgate_);
  }
  // @@protoc_insertion_point(field_mutable:Pmd.ServerName.WebGate)
  return webgate_;
}
inline ::std::string* ServerName::release_webgate() {
  clear_has_webgate();
  if (webgate_ == _default_webgate_) {
    return NULL;
  } else {
    ::std::string* temp = webgate_;
    webgate_ = const_cast< ::std::string*>(_default_webgate_);
    return temp;
  }
}
inline void ServerName::set_allocated_webgate(::std::string* webgate) {
  if (webgate_ != _default_webgate_) {
    delete webgate_;
  }
  if (webgate) {
    set_has_webgate();
    webgate_ = webgate;
  } else {
    clear_has_webgate();
    webgate_ = const_cast< ::std::string*>(_default_webgate_);
  }
  // @@protoc_insertion_point(field_set_allocated:Pmd.ServerName.WebGate)
}

// optional string Sdk = 43 [default = "SdkServer"];
inline bool ServerName::has_sdk() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void ServerName::set_has_sdk() {
  _has_bits_[0] |= 0x00020000u;
}
inline void ServerName::clear_has_sdk() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void ServerName::clear_sdk() {
  if (sdk_ != _default_sdk_) {
    sdk_->assign(*_default_sdk_);
  }
  clear_has_sdk();
}
inline const ::std::string& ServerName::sdk() const {
  // @@protoc_insertion_point(field_get:Pmd.ServerName.Sdk)
  return *sdk_;
}
inline void ServerName::set_sdk(const ::std::string& value) {
  set_has_sdk();
  if (sdk_ == _default_sdk_) {
    sdk_ = new ::std::string;
  }
  sdk_->assign(value);
  // @@protoc_insertion_point(field_set:Pmd.ServerName.Sdk)
}
inline void ServerName::set_sdk(const char* value) {
  set_has_sdk();
  if (sdk_ == _default_sdk_) {
    sdk_ = new ::std::string;
  }
  sdk_->assign(value);
  // @@protoc_insertion_point(field_set_char:Pmd.ServerName.Sdk)
}
inline void ServerName::set_sdk(const char* value, size_t size) {
  set_has_sdk();
  if (sdk_ == _default_sdk_) {
    sdk_ = new ::std::string;
  }
  sdk_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Pmd.ServerName.Sdk)
}
inline ::std::string* ServerName::mutable_sdk() {
  set_has_sdk();
  if (sdk_ == _default_sdk_) {
    sdk_ = new ::std::string(*_default_sdk_);
  }
  // @@protoc_insertion_point(field_mutable:Pmd.ServerName.Sdk)
  return sdk_;
}
inline ::std::string* ServerName::release_sdk() {
  clear_has_sdk();
  if (sdk_ == _default_sdk_) {
    return NULL;
  } else {
    ::std::string* temp = sdk_;
    sdk_ = const_cast< ::std::string*>(_default_sdk_);
    return temp;
  }
}
inline void ServerName::set_allocated_sdk(::std::string* sdk) {
  if (sdk_ != _default_sdk_) {
    delete sdk_;
  }
  if (sdk) {
    set_has_sdk();
    sdk_ = sdk;
  } else {
    clear_has_sdk();
    sdk_ = const_cast< ::std::string*>(_default_sdk_);
  }
  // @@protoc_insertion_point(field_set_allocated:Pmd.ServerName.Sdk)
}

// optional string Logger = 44 [default = "LoggerServer"];
inline bool ServerName::has_logger() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void ServerName::set_has_logger() {
  _has_bits_[0] |= 0x00040000u;
}
inline void ServerName::clear_has_logger() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void ServerName::clear_logger() {
  if (logger_ != _default_logger_) {
    logger_->assign(*_default_logger_);
  }
  clear_has_logger();
}
inline const ::std::string& ServerName::logger() const {
  // @@protoc_insertion_point(field_get:Pmd.ServerName.Logger)
  return *logger_;
}
inline void ServerName::set_logger(const ::std::string& value) {
  set_has_logger();
  if (logger_ == _default_logger_) {
    logger_ = new ::std::string;
  }
  logger_->assign(value);
  // @@protoc_insertion_point(field_set:Pmd.ServerName.Logger)
}
inline void ServerName::set_logger(const char* value) {
  set_has_logger();
  if (logger_ == _default_logger_) {
    logger_ = new ::std::string;
  }
  logger_->assign(value);
  // @@protoc_insertion_point(field_set_char:Pmd.ServerName.Logger)
}
inline void ServerName::set_logger(const char* value, size_t size) {
  set_has_logger();
  if (logger_ == _default_logger_) {
    logger_ = new ::std::string;
  }
  logger_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Pmd.ServerName.Logger)
}
inline ::std::string* ServerName::mutable_logger() {
  set_has_logger();
  if (logger_ == _default_logger_) {
    logger_ = new ::std::string(*_default_logger_);
  }
  // @@protoc_insertion_point(field_mutable:Pmd.ServerName.Logger)
  return logger_;
}
inline ::std::string* ServerName::release_logger() {
  clear_has_logger();
  if (logger_ == _default_logger_) {
    return NULL;
  } else {
    ::std::string* temp = logger_;
    logger_ = const_cast< ::std::string*>(_default_logger_);
    return temp;
  }
}
inline void ServerName::set_allocated_logger(::std::string* logger) {
  if (logger_ != _default_logger_) {
    delete logger_;
  }
  if (logger) {
    set_has_logger();
    logger_ = logger;
  } else {
    clear_has_logger();
    logger_ = const_cast< ::std::string*>(_default_logger_);
  }
  // @@protoc_insertion_point(field_set_allocated:Pmd.ServerName.Logger)
}

// optional string Uni = 45 [default = "UniServer"];
inline bool ServerName::has_uni() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void ServerName::set_has_uni() {
  _has_bits_[0] |= 0x00080000u;
}
inline void ServerName::clear_has_uni() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void ServerName::clear_uni() {
  if (uni_ != _default_uni_) {
    uni_->assign(*_default_uni_);
  }
  clear_has_uni();
}
inline const ::std::string& ServerName::uni() const {
  // @@protoc_insertion_point(field_get:Pmd.ServerName.Uni)
  return *uni_;
}
inline void ServerName::set_uni(const ::std::string& value) {
  set_has_uni();
  if (uni_ == _default_uni_) {
    uni_ = new ::std::string;
  }
  uni_->assign(value);
  // @@protoc_insertion_point(field_set:Pmd.ServerName.Uni)
}
inline void ServerName::set_uni(const char* value) {
  set_has_uni();
  if (uni_ == _default_uni_) {
    uni_ = new ::std::string;
  }
  uni_->assign(value);
  // @@protoc_insertion_point(field_set_char:Pmd.ServerName.Uni)
}
inline void ServerName::set_uni(const char* value, size_t size) {
  set_has_uni();
  if (uni_ == _default_uni_) {
    uni_ = new ::std::string;
  }
  uni_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Pmd.ServerName.Uni)
}
inline ::std::string* ServerName::mutable_uni() {
  set_has_uni();
  if (uni_ == _default_uni_) {
    uni_ = new ::std::string(*_default_uni_);
  }
  // @@protoc_insertion_point(field_mutable:Pmd.ServerName.Uni)
  return uni_;
}
inline ::std::string* ServerName::release_uni() {
  clear_has_uni();
  if (uni_ == _default_uni_) {
    return NULL;
  } else {
    ::std::string* temp = uni_;
    uni_ = const_cast< ::std::string*>(_default_uni_);
    return temp;
  }
}
inline void ServerName::set_allocated_uni(::std::string* uni) {
  if (uni_ != _default_uni_) {
    delete uni_;
  }
  if (uni) {
    set_has_uni();
    uni_ = uni;
  } else {
    clear_has_uni();
    uni_ = const_cast< ::std::string*>(_default_uni_);
  }
  // @@protoc_insertion_point(field_set_allocated:Pmd.ServerName.Uni)
}

// -------------------------------------------------------------------

// ServerInfo

// optional uint32 zoneid = 1;
inline bool ServerInfo::has_zoneid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ServerInfo::set_has_zoneid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ServerInfo::clear_has_zoneid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ServerInfo::clear_zoneid() {
  zoneid_ = 0u;
  clear_has_zoneid();
}
inline ::google::protobuf::uint32 ServerInfo::zoneid() const {
  // @@protoc_insertion_point(field_get:Pmd.ServerInfo.zoneid)
  return zoneid_;
}
inline void ServerInfo::set_zoneid(::google::protobuf::uint32 value) {
  set_has_zoneid();
  zoneid_ = value;
  // @@protoc_insertion_point(field_set:Pmd.ServerInfo.zoneid)
}

// optional uint32 serverid = 2;
inline bool ServerInfo::has_serverid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ServerInfo::set_has_serverid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ServerInfo::clear_has_serverid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ServerInfo::clear_serverid() {
  serverid_ = 0u;
  clear_has_serverid();
}
inline ::google::protobuf::uint32 ServerInfo::serverid() const {
  // @@protoc_insertion_point(field_get:Pmd.ServerInfo.serverid)
  return serverid_;
}
inline void ServerInfo::set_serverid(::google::protobuf::uint32 value) {
  set_has_serverid();
  serverid_ = value;
  // @@protoc_insertion_point(field_set:Pmd.ServerInfo.serverid)
}

// optional uint32 servertype = 3;
inline bool ServerInfo::has_servertype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ServerInfo::set_has_servertype() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ServerInfo::clear_has_servertype() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ServerInfo::clear_servertype() {
  servertype_ = 0u;
  clear_has_servertype();
}
inline ::google::protobuf::uint32 ServerInfo::servertype() const {
  // @@protoc_insertion_point(field_get:Pmd.ServerInfo.servertype)
  return servertype_;
}
inline void ServerInfo::set_servertype(::google::protobuf::uint32 value) {
  set_has_servertype();
  servertype_ = value;
  // @@protoc_insertion_point(field_set:Pmd.ServerInfo.servertype)
}

// optional uint32 protocol = 4;
inline bool ServerInfo::has_protocol() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ServerInfo::set_has_protocol() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ServerInfo::clear_has_protocol() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ServerInfo::clear_protocol() {
  protocol_ = 0u;
  clear_has_protocol();
}
inline ::google::protobuf::uint32 ServerInfo::protocol() const {
  // @@protoc_insertion_point(field_get:Pmd.ServerInfo.protocol)
  return protocol_;
}
inline void ServerInfo::set_protocol(::google::protobuf::uint32 value) {
  set_has_protocol();
  protocol_ = value;
  // @@protoc_insertion_point(field_set:Pmd.ServerInfo.protocol)
}

// optional uint32 buildtime = 5;
inline bool ServerInfo::has_buildtime() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ServerInfo::set_has_buildtime() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ServerInfo::clear_has_buildtime() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ServerInfo::clear_buildtime() {
  buildtime_ = 0u;
  clear_has_buildtime();
}
inline ::google::protobuf::uint32 ServerInfo::buildtime() const {
  // @@protoc_insertion_point(field_get:Pmd.ServerInfo.buildtime)
  return buildtime_;
}
inline void ServerInfo::set_buildtime(::google::protobuf::uint32 value) {
  set_has_buildtime();
  buildtime_ = value;
  // @@protoc_insertion_point(field_set:Pmd.ServerInfo.buildtime)
}

// optional uint32 svnversion = 6;
inline bool ServerInfo::has_svnversion() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ServerInfo::set_has_svnversion() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ServerInfo::clear_has_svnversion() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ServerInfo::clear_svnversion() {
  svnversion_ = 0u;
  clear_has_svnversion();
}
inline ::google::protobuf::uint32 ServerInfo::svnversion() const {
  // @@protoc_insertion_point(field_get:Pmd.ServerInfo.svnversion)
  return svnversion_;
}
inline void ServerInfo::set_svnversion(::google::protobuf::uint32 value) {
  set_has_svnversion();
  svnversion_ = value;
  // @@protoc_insertion_point(field_set:Pmd.ServerInfo.svnversion)
}

// optional uint32 data1 = 7;
inline bool ServerInfo::has_data1() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ServerInfo::set_has_data1() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ServerInfo::clear_has_data1() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ServerInfo::clear_data1() {
  data1_ = 0u;
  clear_has_data1();
}
inline ::google::protobuf::uint32 ServerInfo::data1() const {
  // @@protoc_insertion_point(field_get:Pmd.ServerInfo.data1)
  return data1_;
}
inline void ServerInfo::set_data1(::google::protobuf::uint32 value) {
  set_has_data1();
  data1_ = value;
  // @@protoc_insertion_point(field_set:Pmd.ServerInfo.data1)
}

// optional uint32 funcion = 8;
inline bool ServerInfo::has_funcion() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ServerInfo::set_has_funcion() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ServerInfo::clear_has_funcion() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ServerInfo::clear_funcion() {
  funcion_ = 0u;
  clear_has_funcion();
}
inline ::google::protobuf::uint32 ServerInfo::funcion() const {
  // @@protoc_insertion_point(field_get:Pmd.ServerInfo.funcion)
  return funcion_;
}
inline void ServerInfo::set_funcion(::google::protobuf::uint32 value) {
  set_has_funcion();
  funcion_ = value;
  // @@protoc_insertion_point(field_set:Pmd.ServerInfo.funcion)
}

// optional uint32 reserve0 = 9;
inline bool ServerInfo::has_reserve0() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ServerInfo::set_has_reserve0() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ServerInfo::clear_has_reserve0() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ServerInfo::clear_reserve0() {
  reserve0_ = 0u;
  clear_has_reserve0();
}
inline ::google::protobuf::uint32 ServerInfo::reserve0() const {
  // @@protoc_insertion_point(field_get:Pmd.ServerInfo.reserve0)
  return reserve0_;
}
inline void ServerInfo::set_reserve0(::google::protobuf::uint32 value) {
  set_has_reserve0();
  reserve0_ = value;
  // @@protoc_insertion_point(field_set:Pmd.ServerInfo.reserve0)
}

// optional uint32 reserve1 = 10;
inline bool ServerInfo::has_reserve1() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void ServerInfo::set_has_reserve1() {
  _has_bits_[0] |= 0x00000200u;
}
inline void ServerInfo::clear_has_reserve1() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void ServerInfo::clear_reserve1() {
  reserve1_ = 0u;
  clear_has_reserve1();
}
inline ::google::protobuf::uint32 ServerInfo::reserve1() const {
  // @@protoc_insertion_point(field_get:Pmd.ServerInfo.reserve1)
  return reserve1_;
}
inline void ServerInfo::set_reserve1(::google::protobuf::uint32 value) {
  set_has_reserve1();
  reserve1_ = value;
  // @@protoc_insertion_point(field_set:Pmd.ServerInfo.reserve1)
}

// optional uint32 reserve2 = 11;
inline bool ServerInfo::has_reserve2() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void ServerInfo::set_has_reserve2() {
  _has_bits_[0] |= 0x00000400u;
}
inline void ServerInfo::clear_has_reserve2() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void ServerInfo::clear_reserve2() {
  reserve2_ = 0u;
  clear_has_reserve2();
}
inline ::google::protobuf::uint32 ServerInfo::reserve2() const {
  // @@protoc_insertion_point(field_get:Pmd.ServerInfo.reserve2)
  return reserve2_;
}
inline void ServerInfo::set_reserve2(::google::protobuf::uint32 value) {
  set_has_reserve2();
  reserve2_ = value;
  // @@protoc_insertion_point(field_set:Pmd.ServerInfo.reserve2)
}

// optional uint32 reserve3 = 12;
inline bool ServerInfo::has_reserve3() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void ServerInfo::set_has_reserve3() {
  _has_bits_[0] |= 0x00000800u;
}
inline void ServerInfo::clear_has_reserve3() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void ServerInfo::clear_reserve3() {
  reserve3_ = 0u;
  clear_has_reserve3();
}
inline ::google::protobuf::uint32 ServerInfo::reserve3() const {
  // @@protoc_insertion_point(field_get:Pmd.ServerInfo.reserve3)
  return reserve3_;
}
inline void ServerInfo::set_reserve3(::google::protobuf::uint32 value) {
  set_has_reserve3();
  reserve3_ = value;
  // @@protoc_insertion_point(field_set:Pmd.ServerInfo.reserve3)
}

// optional uint32 serverip = 13;
inline bool ServerInfo::has_serverip() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void ServerInfo::set_has_serverip() {
  _has_bits_[0] |= 0x00001000u;
}
inline void ServerInfo::clear_has_serverip() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void ServerInfo::clear_serverip() {
  serverip_ = 0u;
  clear_has_serverip();
}
inline ::google::protobuf::uint32 ServerInfo::serverip() const {
  // @@protoc_insertion_point(field_get:Pmd.ServerInfo.serverip)
  return serverip_;
}
inline void ServerInfo::set_serverip(::google::protobuf::uint32 value) {
  set_has_serverip();
  serverip_ = value;
  // @@protoc_insertion_point(field_set:Pmd.ServerInfo.serverip)
}

// optional uint32 usernum = 14;
inline bool ServerInfo::has_usernum() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void ServerInfo::set_has_usernum() {
  _has_bits_[0] |= 0x00002000u;
}
inline void ServerInfo::clear_has_usernum() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void ServerInfo::clear_usernum() {
  usernum_ = 0u;
  clear_has_usernum();
}
inline ::google::protobuf::uint32 ServerInfo::usernum() const {
  // @@protoc_insertion_point(field_get:Pmd.ServerInfo.usernum)
  return usernum_;
}
inline void ServerInfo::set_usernum(::google::protobuf::uint32 value) {
  set_has_usernum();
  usernum_ = value;
  // @@protoc_insertion_point(field_set:Pmd.ServerInfo.usernum)
}

// optional uint32 time = 15;
inline bool ServerInfo::has_time() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void ServerInfo::set_has_time() {
  _has_bits_[0] |= 0x00004000u;
}
inline void ServerInfo::clear_has_time() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void ServerInfo::clear_time() {
  time_ = 0u;
  clear_has_time();
}
inline ::google::protobuf::uint32 ServerInfo::time() const {
  // @@protoc_insertion_point(field_get:Pmd.ServerInfo.time)
  return time_;
}
inline void ServerInfo::set_time(::google::protobuf::uint32 value) {
  set_has_time();
  time_ = value;
  // @@protoc_insertion_point(field_set:Pmd.ServerInfo.time)
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace Pmd

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::Pmd::PlatCommand> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Pmd::PlatCommand>() {
  return ::Pmd::PlatCommand_descriptor();
}
template <> struct is_proto_enum< ::Pmd::HttpReturnCode> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Pmd::HttpReturnCode>() {
  return ::Pmd::HttpReturnCode_descriptor();
}
template <> struct is_proto_enum< ::Pmd::TaskType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Pmd::TaskType>() {
  return ::Pmd::TaskType_descriptor();
}
template <> struct is_proto_enum< ::Pmd::ServerType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Pmd::ServerType>() {
  return ::Pmd::ServerType_descriptor();
}
template <> struct is_proto_enum< ::Pmd::NetType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Pmd::NetType>() {
  return ::Pmd::NetType_descriptor();
}
template <> struct is_proto_enum< ::Pmd::RobotUid> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Pmd::RobotUid>() {
  return ::Pmd::RobotUid_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_pmd_2eproto__INCLUDED
