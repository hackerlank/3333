// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: loggercommand.proto

#ifndef PROTOBUF_loggercommand_2eproto__INCLUDED
#define PROTOBUF_loggercommand_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "pmd.pb.h"
// @@protoc_insertion_point(includes)

namespace Pmd {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_loggercommand_2eproto();
void protobuf_AssignDesc_loggercommand_2eproto();
void protobuf_ShutdownFile_loggercommand_2eproto();

class Logger;
class StartUpLoggerRequestLoggerPmd_C;
class StartUpLoggerReturnLoggerPmd_S;
class LineInfo;
class GameZoneNewLineRequestLoggerPmd_C;
class GameZoneNewLineWriteLoggerPmd_S;
class GameZoneHistoryLineRequestLoggerPmd_C;
class GameZoneHistoryLineWriteLoggerPmd_S;

enum Logger_Param {
  Logger_Param_StartUpLoggerRequestLoggerPmd_C = 1,
  Logger_Param_StartUpLoggerReturnLoggerPmd_S = 2,
  Logger_Param_GameZoneNewLineRequestLoggerPmd_C = 3,
  Logger_Param_GameZoneNewLineWriteLoggerPmd_S = 4,
  Logger_Param_GameZoneHistoryLineRequestLoggerPmd_C = 5,
  Logger_Param_GameZoneHistoryLineWriteLoggerPmd_S = 6
};
bool Logger_Param_IsValid(int value);
const Logger_Param Logger_Param_Param_MIN = Logger_Param_StartUpLoggerRequestLoggerPmd_C;
const Logger_Param Logger_Param_Param_MAX = Logger_Param_GameZoneHistoryLineWriteLoggerPmd_S;
const int Logger_Param_Param_ARRAYSIZE = Logger_Param_Param_MAX + 1;

const ::google::protobuf::EnumDescriptor* Logger_Param_descriptor();
inline const ::std::string& Logger_Param_Name(Logger_Param value) {
  return ::google::protobuf::internal::NameOfEnum(
    Logger_Param_descriptor(), value);
}
inline bool Logger_Param_Parse(
    const ::std::string& name, Logger_Param* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Logger_Param>(
    Logger_Param_descriptor(), name, value);
}
// ===================================================================

class Logger : public ::google::protobuf::Message {
 public:
  Logger();
  virtual ~Logger();

  Logger(const Logger& from);

  inline Logger& operator=(const Logger& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Logger& default_instance();

  void Swap(Logger* other);

  // implements Message ----------------------------------------------

  Logger* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Logger& from);
  void MergeFrom(const Logger& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Logger_Param Param;
  static const Param StartUpLoggerRequestLoggerPmd_C = Logger_Param_StartUpLoggerRequestLoggerPmd_C;
  static const Param StartUpLoggerReturnLoggerPmd_S = Logger_Param_StartUpLoggerReturnLoggerPmd_S;
  static const Param GameZoneNewLineRequestLoggerPmd_C = Logger_Param_GameZoneNewLineRequestLoggerPmd_C;
  static const Param GameZoneNewLineWriteLoggerPmd_S = Logger_Param_GameZoneNewLineWriteLoggerPmd_S;
  static const Param GameZoneHistoryLineRequestLoggerPmd_C = Logger_Param_GameZoneHistoryLineRequestLoggerPmd_C;
  static const Param GameZoneHistoryLineWriteLoggerPmd_S = Logger_Param_GameZoneHistoryLineWriteLoggerPmd_S;
  static inline bool Param_IsValid(int value) {
    return Logger_Param_IsValid(value);
  }
  static const Param Param_MIN =
    Logger_Param_Param_MIN;
  static const Param Param_MAX =
    Logger_Param_Param_MAX;
  static const int Param_ARRAYSIZE =
    Logger_Param_Param_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Param_descriptor() {
    return Logger_Param_descriptor();
  }
  static inline const ::std::string& Param_Name(Param value) {
    return Logger_Param_Name(value);
  }
  static inline bool Param_Parse(const ::std::string& name,
      Param* value) {
    return Logger_Param_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:Pmd.Logger)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_loggercommand_2eproto();
  friend void protobuf_AssignDesc_loggercommand_2eproto();
  friend void protobuf_ShutdownFile_loggercommand_2eproto();

  void InitAsDefaultInstance();
  static Logger* default_instance_;
};
// -------------------------------------------------------------------

class StartUpLoggerRequestLoggerPmd_C : public ::google::protobuf::Message {
 public:
  StartUpLoggerRequestLoggerPmd_C();
  virtual ~StartUpLoggerRequestLoggerPmd_C();

  StartUpLoggerRequestLoggerPmd_C(const StartUpLoggerRequestLoggerPmd_C& from);

  inline StartUpLoggerRequestLoggerPmd_C& operator=(const StartUpLoggerRequestLoggerPmd_C& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const StartUpLoggerRequestLoggerPmd_C& default_instance();

  void Swap(StartUpLoggerRequestLoggerPmd_C* other);

  // implements Message ----------------------------------------------

  StartUpLoggerRequestLoggerPmd_C* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StartUpLoggerRequestLoggerPmd_C& from);
  void MergeFrom(const StartUpLoggerRequestLoggerPmd_C& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string key = 1;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 1;
  inline const ::std::string& key() const;
  inline void set_key(const ::std::string& value);
  inline void set_key(const char* value);
  inline void set_key(const char* value, size_t size);
  inline ::std::string* mutable_key();
  inline ::std::string* release_key();
  inline void set_allocated_key(::std::string* key);

  // optional uint32 version = 2;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 2;
  inline ::google::protobuf::uint32 version() const;
  inline void set_version(::google::protobuf::uint32 value);

  // optional string compress = 3;
  inline bool has_compress() const;
  inline void clear_compress();
  static const int kCompressFieldNumber = 3;
  inline const ::std::string& compress() const;
  inline void set_compress(const ::std::string& value);
  inline void set_compress(const char* value);
  inline void set_compress(const char* value, size_t size);
  inline ::std::string* mutable_compress();
  inline ::std::string* release_compress();
  inline void set_allocated_compress(::std::string* compress);

  // optional string encrypt = 4;
  inline bool has_encrypt() const;
  inline void clear_encrypt();
  static const int kEncryptFieldNumber = 4;
  inline const ::std::string& encrypt() const;
  inline void set_encrypt(const ::std::string& value);
  inline void set_encrypt(const char* value);
  inline void set_encrypt(const char* value, size_t size);
  inline ::std::string* mutable_encrypt();
  inline ::std::string* release_encrypt();
  inline void set_allocated_encrypt(::std::string* encrypt);

  // optional string encryptkey = 5;
  inline bool has_encryptkey() const;
  inline void clear_encryptkey();
  static const int kEncryptkeyFieldNumber = 5;
  inline const ::std::string& encryptkey() const;
  inline void set_encryptkey(const ::std::string& value);
  inline void set_encryptkey(const char* value);
  inline void set_encryptkey(const char* value, size_t size);
  inline ::std::string* mutable_encryptkey();
  inline ::std::string* release_encryptkey();
  inline void set_allocated_encryptkey(::std::string* encryptkey);

  // @@protoc_insertion_point(class_scope:Pmd.StartUpLoggerRequestLoggerPmd_C)
 private:
  inline void set_has_key();
  inline void clear_has_key();
  inline void set_has_version();
  inline void clear_has_version();
  inline void set_has_compress();
  inline void clear_has_compress();
  inline void set_has_encrypt();
  inline void clear_has_encrypt();
  inline void set_has_encryptkey();
  inline void clear_has_encryptkey();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* key_;
  ::std::string* compress_;
  ::std::string* encrypt_;
  ::std::string* encryptkey_;
  ::google::protobuf::uint32 version_;
  friend void  protobuf_AddDesc_loggercommand_2eproto();
  friend void protobuf_AssignDesc_loggercommand_2eproto();
  friend void protobuf_ShutdownFile_loggercommand_2eproto();

  void InitAsDefaultInstance();
  static StartUpLoggerRequestLoggerPmd_C* default_instance_;
};
// -------------------------------------------------------------------

class StartUpLoggerReturnLoggerPmd_S : public ::google::protobuf::Message {
 public:
  StartUpLoggerReturnLoggerPmd_S();
  virtual ~StartUpLoggerReturnLoggerPmd_S();

  StartUpLoggerReturnLoggerPmd_S(const StartUpLoggerReturnLoggerPmd_S& from);

  inline StartUpLoggerReturnLoggerPmd_S& operator=(const StartUpLoggerReturnLoggerPmd_S& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const StartUpLoggerReturnLoggerPmd_S& default_instance();

  void Swap(StartUpLoggerReturnLoggerPmd_S* other);

  // implements Message ----------------------------------------------

  StartUpLoggerReturnLoggerPmd_S* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StartUpLoggerReturnLoggerPmd_S& from);
  void MergeFrom(const StartUpLoggerReturnLoggerPmd_S& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool ret = 1;
  inline bool has_ret() const;
  inline void clear_ret();
  static const int kRetFieldNumber = 1;
  inline bool ret() const;
  inline void set_ret(bool value);

  // optional string retdesc = 2;
  inline bool has_retdesc() const;
  inline void clear_retdesc();
  static const int kRetdescFieldNumber = 2;
  inline const ::std::string& retdesc() const;
  inline void set_retdesc(const ::std::string& value);
  inline void set_retdesc(const char* value);
  inline void set_retdesc(const char* value, size_t size);
  inline ::std::string* mutable_retdesc();
  inline ::std::string* release_retdesc();
  inline void set_allocated_retdesc(::std::string* retdesc);

  // @@protoc_insertion_point(class_scope:Pmd.StartUpLoggerReturnLoggerPmd_S)
 private:
  inline void set_has_ret();
  inline void clear_has_ret();
  inline void set_has_retdesc();
  inline void clear_has_retdesc();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* retdesc_;
  bool ret_;
  friend void  protobuf_AddDesc_loggercommand_2eproto();
  friend void protobuf_AssignDesc_loggercommand_2eproto();
  friend void protobuf_ShutdownFile_loggercommand_2eproto();

  void InitAsDefaultInstance();
  static StartUpLoggerReturnLoggerPmd_S* default_instance_;
};
// -------------------------------------------------------------------

class LineInfo : public ::google::protobuf::Message {
 public:
  LineInfo();
  virtual ~LineInfo();

  LineInfo(const LineInfo& from);

  inline LineInfo& operator=(const LineInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LineInfo& default_instance();

  void Swap(LineInfo* other);

  // implements Message ----------------------------------------------

  LineInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LineInfo& from);
  void MergeFrom(const LineInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint64 id() const;
  inline void set_id(::google::protobuf::uint64 value);

  // optional string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional string classname = 3;
  inline bool has_classname() const;
  inline void clear_classname();
  static const int kClassnameFieldNumber = 3;
  inline const ::std::string& classname() const;
  inline void set_classname(const ::std::string& value);
  inline void set_classname(const char* value);
  inline void set_classname(const char* value, size_t size);
  inline ::std::string* mutable_classname();
  inline ::std::string* release_classname();
  inline void set_allocated_classname(::std::string* classname);

  // optional string servername = 4;
  inline bool has_servername() const;
  inline void clear_servername();
  static const int kServernameFieldNumber = 4;
  inline const ::std::string& servername() const;
  inline void set_servername(const ::std::string& value);
  inline void set_servername(const char* value);
  inline void set_servername(const char* value, size_t size);
  inline ::std::string* mutable_servername();
  inline ::std::string* release_servername();
  inline void set_allocated_servername(::std::string* servername);

  // optional uint32 level = 5;
  inline bool has_level() const;
  inline void clear_level();
  static const int kLevelFieldNumber = 5;
  inline ::google::protobuf::uint32 level() const;
  inline void set_level(::google::protobuf::uint32 value);

  // optional uint32 timestamp = 6;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimestampFieldNumber = 6;
  inline ::google::protobuf::uint32 timestamp() const;
  inline void set_timestamp(::google::protobuf::uint32 value);

  // optional string log = 7;
  inline bool has_log() const;
  inline void clear_log();
  static const int kLogFieldNumber = 7;
  inline const ::std::string& log() const;
  inline void set_log(const ::std::string& value);
  inline void set_log(const char* value);
  inline void set_log(const char* value, size_t size);
  inline ::std::string* mutable_log();
  inline ::std::string* release_log();
  inline void set_allocated_log(::std::string* log);

  // @@protoc_insertion_point(class_scope:Pmd.LineInfo)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_classname();
  inline void clear_has_classname();
  inline void set_has_servername();
  inline void clear_has_servername();
  inline void set_has_level();
  inline void clear_has_level();
  inline void set_has_timestamp();
  inline void clear_has_timestamp();
  inline void set_has_log();
  inline void clear_has_log();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 id_;
  ::std::string* name_;
  ::std::string* classname_;
  ::std::string* servername_;
  ::google::protobuf::uint32 level_;
  ::google::protobuf::uint32 timestamp_;
  ::std::string* log_;
  friend void  protobuf_AddDesc_loggercommand_2eproto();
  friend void protobuf_AssignDesc_loggercommand_2eproto();
  friend void protobuf_ShutdownFile_loggercommand_2eproto();

  void InitAsDefaultInstance();
  static LineInfo* default_instance_;
};
// -------------------------------------------------------------------

class GameZoneNewLineRequestLoggerPmd_C : public ::google::protobuf::Message {
 public:
  GameZoneNewLineRequestLoggerPmd_C();
  virtual ~GameZoneNewLineRequestLoggerPmd_C();

  GameZoneNewLineRequestLoggerPmd_C(const GameZoneNewLineRequestLoggerPmd_C& from);

  inline GameZoneNewLineRequestLoggerPmd_C& operator=(const GameZoneNewLineRequestLoggerPmd_C& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GameZoneNewLineRequestLoggerPmd_C& default_instance();

  void Swap(GameZoneNewLineRequestLoggerPmd_C* other);

  // implements Message ----------------------------------------------

  GameZoneNewLineRequestLoggerPmd_C* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GameZoneNewLineRequestLoggerPmd_C& from);
  void MergeFrom(const GameZoneNewLineRequestLoggerPmd_C& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Pmd.GameZoneInfo gamezone = 1;
  inline bool has_gamezone() const;
  inline void clear_gamezone();
  static const int kGamezoneFieldNumber = 1;
  inline const ::Pmd::GameZoneInfo& gamezone() const;
  inline ::Pmd::GameZoneInfo* mutable_gamezone();
  inline ::Pmd::GameZoneInfo* release_gamezone();
  inline void set_allocated_gamezone(::Pmd::GameZoneInfo* gamezone);

  // optional .Pmd.LineInfo filter = 2;
  inline bool has_filter() const;
  inline void clear_filter();
  static const int kFilterFieldNumber = 2;
  inline const ::Pmd::LineInfo& filter() const;
  inline ::Pmd::LineInfo* mutable_filter();
  inline ::Pmd::LineInfo* release_filter();
  inline void set_allocated_filter(::Pmd::LineInfo* filter);

  // @@protoc_insertion_point(class_scope:Pmd.GameZoneNewLineRequestLoggerPmd_C)
 private:
  inline void set_has_gamezone();
  inline void clear_has_gamezone();
  inline void set_has_filter();
  inline void clear_has_filter();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::Pmd::GameZoneInfo* gamezone_;
  ::Pmd::LineInfo* filter_;
  friend void  protobuf_AddDesc_loggercommand_2eproto();
  friend void protobuf_AssignDesc_loggercommand_2eproto();
  friend void protobuf_ShutdownFile_loggercommand_2eproto();

  void InitAsDefaultInstance();
  static GameZoneNewLineRequestLoggerPmd_C* default_instance_;
};
// -------------------------------------------------------------------

class GameZoneNewLineWriteLoggerPmd_S : public ::google::protobuf::Message {
 public:
  GameZoneNewLineWriteLoggerPmd_S();
  virtual ~GameZoneNewLineWriteLoggerPmd_S();

  GameZoneNewLineWriteLoggerPmd_S(const GameZoneNewLineWriteLoggerPmd_S& from);

  inline GameZoneNewLineWriteLoggerPmd_S& operator=(const GameZoneNewLineWriteLoggerPmd_S& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GameZoneNewLineWriteLoggerPmd_S& default_instance();

  void Swap(GameZoneNewLineWriteLoggerPmd_S* other);

  // implements Message ----------------------------------------------

  GameZoneNewLineWriteLoggerPmd_S* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GameZoneNewLineWriteLoggerPmd_S& from);
  void MergeFrom(const GameZoneNewLineWriteLoggerPmd_S& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Pmd.LineInfo line = 1;
  inline bool has_line() const;
  inline void clear_line();
  static const int kLineFieldNumber = 1;
  inline const ::Pmd::LineInfo& line() const;
  inline ::Pmd::LineInfo* mutable_line();
  inline ::Pmd::LineInfo* release_line();
  inline void set_allocated_line(::Pmd::LineInfo* line);

  // @@protoc_insertion_point(class_scope:Pmd.GameZoneNewLineWriteLoggerPmd_S)
 private:
  inline void set_has_line();
  inline void clear_has_line();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::Pmd::LineInfo* line_;
  friend void  protobuf_AddDesc_loggercommand_2eproto();
  friend void protobuf_AssignDesc_loggercommand_2eproto();
  friend void protobuf_ShutdownFile_loggercommand_2eproto();

  void InitAsDefaultInstance();
  static GameZoneNewLineWriteLoggerPmd_S* default_instance_;
};
// -------------------------------------------------------------------

class GameZoneHistoryLineRequestLoggerPmd_C : public ::google::protobuf::Message {
 public:
  GameZoneHistoryLineRequestLoggerPmd_C();
  virtual ~GameZoneHistoryLineRequestLoggerPmd_C();

  GameZoneHistoryLineRequestLoggerPmd_C(const GameZoneHistoryLineRequestLoggerPmd_C& from);

  inline GameZoneHistoryLineRequestLoggerPmd_C& operator=(const GameZoneHistoryLineRequestLoggerPmd_C& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GameZoneHistoryLineRequestLoggerPmd_C& default_instance();

  void Swap(GameZoneHistoryLineRequestLoggerPmd_C* other);

  // implements Message ----------------------------------------------

  GameZoneHistoryLineRequestLoggerPmd_C* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GameZoneHistoryLineRequestLoggerPmd_C& from);
  void MergeFrom(const GameZoneHistoryLineRequestLoggerPmd_C& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Pmd.GameZoneInfo gamezone = 1;
  inline bool has_gamezone() const;
  inline void clear_gamezone();
  static const int kGamezoneFieldNumber = 1;
  inline const ::Pmd::GameZoneInfo& gamezone() const;
  inline ::Pmd::GameZoneInfo* mutable_gamezone();
  inline ::Pmd::GameZoneInfo* release_gamezone();
  inline void set_allocated_gamezone(::Pmd::GameZoneInfo* gamezone);

  // optional .Pmd.LineInfo filter = 2;
  inline bool has_filter() const;
  inline void clear_filter();
  static const int kFilterFieldNumber = 2;
  inline const ::Pmd::LineInfo& filter() const;
  inline ::Pmd::LineInfo* mutable_filter();
  inline ::Pmd::LineInfo* release_filter();
  inline void set_allocated_filter(::Pmd::LineInfo* filter);

  // @@protoc_insertion_point(class_scope:Pmd.GameZoneHistoryLineRequestLoggerPmd_C)
 private:
  inline void set_has_gamezone();
  inline void clear_has_gamezone();
  inline void set_has_filter();
  inline void clear_has_filter();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::Pmd::GameZoneInfo* gamezone_;
  ::Pmd::LineInfo* filter_;
  friend void  protobuf_AddDesc_loggercommand_2eproto();
  friend void protobuf_AssignDesc_loggercommand_2eproto();
  friend void protobuf_ShutdownFile_loggercommand_2eproto();

  void InitAsDefaultInstance();
  static GameZoneHistoryLineRequestLoggerPmd_C* default_instance_;
};
// -------------------------------------------------------------------

class GameZoneHistoryLineWriteLoggerPmd_S : public ::google::protobuf::Message {
 public:
  GameZoneHistoryLineWriteLoggerPmd_S();
  virtual ~GameZoneHistoryLineWriteLoggerPmd_S();

  GameZoneHistoryLineWriteLoggerPmd_S(const GameZoneHistoryLineWriteLoggerPmd_S& from);

  inline GameZoneHistoryLineWriteLoggerPmd_S& operator=(const GameZoneHistoryLineWriteLoggerPmd_S& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GameZoneHistoryLineWriteLoggerPmd_S& default_instance();

  void Swap(GameZoneHistoryLineWriteLoggerPmd_S* other);

  // implements Message ----------------------------------------------

  GameZoneHistoryLineWriteLoggerPmd_S* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GameZoneHistoryLineWriteLoggerPmd_S& from);
  void MergeFrom(const GameZoneHistoryLineWriteLoggerPmd_S& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Pmd.LineInfo linelist = 1;
  inline int linelist_size() const;
  inline void clear_linelist();
  static const int kLinelistFieldNumber = 1;
  inline const ::Pmd::LineInfo& linelist(int index) const;
  inline ::Pmd::LineInfo* mutable_linelist(int index);
  inline ::Pmd::LineInfo* add_linelist();
  inline const ::google::protobuf::RepeatedPtrField< ::Pmd::LineInfo >&
      linelist() const;
  inline ::google::protobuf::RepeatedPtrField< ::Pmd::LineInfo >*
      mutable_linelist();

  // @@protoc_insertion_point(class_scope:Pmd.GameZoneHistoryLineWriteLoggerPmd_S)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::Pmd::LineInfo > linelist_;
  friend void  protobuf_AddDesc_loggercommand_2eproto();
  friend void protobuf_AssignDesc_loggercommand_2eproto();
  friend void protobuf_ShutdownFile_loggercommand_2eproto();

  void InitAsDefaultInstance();
  static GameZoneHistoryLineWriteLoggerPmd_S* default_instance_;
};
// ===================================================================


// ===================================================================

// Logger

// -------------------------------------------------------------------

// StartUpLoggerRequestLoggerPmd_C

// optional string key = 1;
inline bool StartUpLoggerRequestLoggerPmd_C::has_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StartUpLoggerRequestLoggerPmd_C::set_has_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StartUpLoggerRequestLoggerPmd_C::clear_has_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StartUpLoggerRequestLoggerPmd_C::clear_key() {
  if (key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_->clear();
  }
  clear_has_key();
}
inline const ::std::string& StartUpLoggerRequestLoggerPmd_C::key() const {
  // @@protoc_insertion_point(field_get:Pmd.StartUpLoggerRequestLoggerPmd_C.key)
  return *key_;
}
inline void StartUpLoggerRequestLoggerPmd_C::set_key(const ::std::string& value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(value);
  // @@protoc_insertion_point(field_set:Pmd.StartUpLoggerRequestLoggerPmd_C.key)
}
inline void StartUpLoggerRequestLoggerPmd_C::set_key(const char* value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(value);
  // @@protoc_insertion_point(field_set_char:Pmd.StartUpLoggerRequestLoggerPmd_C.key)
}
inline void StartUpLoggerRequestLoggerPmd_C::set_key(const char* value, size_t size) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Pmd.StartUpLoggerRequestLoggerPmd_C.key)
}
inline ::std::string* StartUpLoggerRequestLoggerPmd_C::mutable_key() {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Pmd.StartUpLoggerRequestLoggerPmd_C.key)
  return key_;
}
inline ::std::string* StartUpLoggerRequestLoggerPmd_C::release_key() {
  clear_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = key_;
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void StartUpLoggerRequestLoggerPmd_C::set_allocated_key(::std::string* key) {
  if (key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete key_;
  }
  if (key) {
    set_has_key();
    key_ = key;
  } else {
    clear_has_key();
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Pmd.StartUpLoggerRequestLoggerPmd_C.key)
}

// optional uint32 version = 2;
inline bool StartUpLoggerRequestLoggerPmd_C::has_version() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void StartUpLoggerRequestLoggerPmd_C::set_has_version() {
  _has_bits_[0] |= 0x00000002u;
}
inline void StartUpLoggerRequestLoggerPmd_C::clear_has_version() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void StartUpLoggerRequestLoggerPmd_C::clear_version() {
  version_ = 0u;
  clear_has_version();
}
inline ::google::protobuf::uint32 StartUpLoggerRequestLoggerPmd_C::version() const {
  // @@protoc_insertion_point(field_get:Pmd.StartUpLoggerRequestLoggerPmd_C.version)
  return version_;
}
inline void StartUpLoggerRequestLoggerPmd_C::set_version(::google::protobuf::uint32 value) {
  set_has_version();
  version_ = value;
  // @@protoc_insertion_point(field_set:Pmd.StartUpLoggerRequestLoggerPmd_C.version)
}

// optional string compress = 3;
inline bool StartUpLoggerRequestLoggerPmd_C::has_compress() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void StartUpLoggerRequestLoggerPmd_C::set_has_compress() {
  _has_bits_[0] |= 0x00000004u;
}
inline void StartUpLoggerRequestLoggerPmd_C::clear_has_compress() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void StartUpLoggerRequestLoggerPmd_C::clear_compress() {
  if (compress_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    compress_->clear();
  }
  clear_has_compress();
}
inline const ::std::string& StartUpLoggerRequestLoggerPmd_C::compress() const {
  // @@protoc_insertion_point(field_get:Pmd.StartUpLoggerRequestLoggerPmd_C.compress)
  return *compress_;
}
inline void StartUpLoggerRequestLoggerPmd_C::set_compress(const ::std::string& value) {
  set_has_compress();
  if (compress_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    compress_ = new ::std::string;
  }
  compress_->assign(value);
  // @@protoc_insertion_point(field_set:Pmd.StartUpLoggerRequestLoggerPmd_C.compress)
}
inline void StartUpLoggerRequestLoggerPmd_C::set_compress(const char* value) {
  set_has_compress();
  if (compress_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    compress_ = new ::std::string;
  }
  compress_->assign(value);
  // @@protoc_insertion_point(field_set_char:Pmd.StartUpLoggerRequestLoggerPmd_C.compress)
}
inline void StartUpLoggerRequestLoggerPmd_C::set_compress(const char* value, size_t size) {
  set_has_compress();
  if (compress_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    compress_ = new ::std::string;
  }
  compress_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Pmd.StartUpLoggerRequestLoggerPmd_C.compress)
}
inline ::std::string* StartUpLoggerRequestLoggerPmd_C::mutable_compress() {
  set_has_compress();
  if (compress_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    compress_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Pmd.StartUpLoggerRequestLoggerPmd_C.compress)
  return compress_;
}
inline ::std::string* StartUpLoggerRequestLoggerPmd_C::release_compress() {
  clear_has_compress();
  if (compress_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = compress_;
    compress_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void StartUpLoggerRequestLoggerPmd_C::set_allocated_compress(::std::string* compress) {
  if (compress_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete compress_;
  }
  if (compress) {
    set_has_compress();
    compress_ = compress;
  } else {
    clear_has_compress();
    compress_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Pmd.StartUpLoggerRequestLoggerPmd_C.compress)
}

// optional string encrypt = 4;
inline bool StartUpLoggerRequestLoggerPmd_C::has_encrypt() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void StartUpLoggerRequestLoggerPmd_C::set_has_encrypt() {
  _has_bits_[0] |= 0x00000008u;
}
inline void StartUpLoggerRequestLoggerPmd_C::clear_has_encrypt() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void StartUpLoggerRequestLoggerPmd_C::clear_encrypt() {
  if (encrypt_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    encrypt_->clear();
  }
  clear_has_encrypt();
}
inline const ::std::string& StartUpLoggerRequestLoggerPmd_C::encrypt() const {
  // @@protoc_insertion_point(field_get:Pmd.StartUpLoggerRequestLoggerPmd_C.encrypt)
  return *encrypt_;
}
inline void StartUpLoggerRequestLoggerPmd_C::set_encrypt(const ::std::string& value) {
  set_has_encrypt();
  if (encrypt_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    encrypt_ = new ::std::string;
  }
  encrypt_->assign(value);
  // @@protoc_insertion_point(field_set:Pmd.StartUpLoggerRequestLoggerPmd_C.encrypt)
}
inline void StartUpLoggerRequestLoggerPmd_C::set_encrypt(const char* value) {
  set_has_encrypt();
  if (encrypt_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    encrypt_ = new ::std::string;
  }
  encrypt_->assign(value);
  // @@protoc_insertion_point(field_set_char:Pmd.StartUpLoggerRequestLoggerPmd_C.encrypt)
}
inline void StartUpLoggerRequestLoggerPmd_C::set_encrypt(const char* value, size_t size) {
  set_has_encrypt();
  if (encrypt_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    encrypt_ = new ::std::string;
  }
  encrypt_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Pmd.StartUpLoggerRequestLoggerPmd_C.encrypt)
}
inline ::std::string* StartUpLoggerRequestLoggerPmd_C::mutable_encrypt() {
  set_has_encrypt();
  if (encrypt_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    encrypt_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Pmd.StartUpLoggerRequestLoggerPmd_C.encrypt)
  return encrypt_;
}
inline ::std::string* StartUpLoggerRequestLoggerPmd_C::release_encrypt() {
  clear_has_encrypt();
  if (encrypt_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = encrypt_;
    encrypt_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void StartUpLoggerRequestLoggerPmd_C::set_allocated_encrypt(::std::string* encrypt) {
  if (encrypt_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete encrypt_;
  }
  if (encrypt) {
    set_has_encrypt();
    encrypt_ = encrypt;
  } else {
    clear_has_encrypt();
    encrypt_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Pmd.StartUpLoggerRequestLoggerPmd_C.encrypt)
}

// optional string encryptkey = 5;
inline bool StartUpLoggerRequestLoggerPmd_C::has_encryptkey() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void StartUpLoggerRequestLoggerPmd_C::set_has_encryptkey() {
  _has_bits_[0] |= 0x00000010u;
}
inline void StartUpLoggerRequestLoggerPmd_C::clear_has_encryptkey() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void StartUpLoggerRequestLoggerPmd_C::clear_encryptkey() {
  if (encryptkey_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    encryptkey_->clear();
  }
  clear_has_encryptkey();
}
inline const ::std::string& StartUpLoggerRequestLoggerPmd_C::encryptkey() const {
  // @@protoc_insertion_point(field_get:Pmd.StartUpLoggerRequestLoggerPmd_C.encryptkey)
  return *encryptkey_;
}
inline void StartUpLoggerRequestLoggerPmd_C::set_encryptkey(const ::std::string& value) {
  set_has_encryptkey();
  if (encryptkey_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    encryptkey_ = new ::std::string;
  }
  encryptkey_->assign(value);
  // @@protoc_insertion_point(field_set:Pmd.StartUpLoggerRequestLoggerPmd_C.encryptkey)
}
inline void StartUpLoggerRequestLoggerPmd_C::set_encryptkey(const char* value) {
  set_has_encryptkey();
  if (encryptkey_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    encryptkey_ = new ::std::string;
  }
  encryptkey_->assign(value);
  // @@protoc_insertion_point(field_set_char:Pmd.StartUpLoggerRequestLoggerPmd_C.encryptkey)
}
inline void StartUpLoggerRequestLoggerPmd_C::set_encryptkey(const char* value, size_t size) {
  set_has_encryptkey();
  if (encryptkey_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    encryptkey_ = new ::std::string;
  }
  encryptkey_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Pmd.StartUpLoggerRequestLoggerPmd_C.encryptkey)
}
inline ::std::string* StartUpLoggerRequestLoggerPmd_C::mutable_encryptkey() {
  set_has_encryptkey();
  if (encryptkey_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    encryptkey_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Pmd.StartUpLoggerRequestLoggerPmd_C.encryptkey)
  return encryptkey_;
}
inline ::std::string* StartUpLoggerRequestLoggerPmd_C::release_encryptkey() {
  clear_has_encryptkey();
  if (encryptkey_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = encryptkey_;
    encryptkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void StartUpLoggerRequestLoggerPmd_C::set_allocated_encryptkey(::std::string* encryptkey) {
  if (encryptkey_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete encryptkey_;
  }
  if (encryptkey) {
    set_has_encryptkey();
    encryptkey_ = encryptkey;
  } else {
    clear_has_encryptkey();
    encryptkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Pmd.StartUpLoggerRequestLoggerPmd_C.encryptkey)
}

// -------------------------------------------------------------------

// StartUpLoggerReturnLoggerPmd_S

// optional bool ret = 1;
inline bool StartUpLoggerReturnLoggerPmd_S::has_ret() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StartUpLoggerReturnLoggerPmd_S::set_has_ret() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StartUpLoggerReturnLoggerPmd_S::clear_has_ret() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StartUpLoggerReturnLoggerPmd_S::clear_ret() {
  ret_ = false;
  clear_has_ret();
}
inline bool StartUpLoggerReturnLoggerPmd_S::ret() const {
  // @@protoc_insertion_point(field_get:Pmd.StartUpLoggerReturnLoggerPmd_S.ret)
  return ret_;
}
inline void StartUpLoggerReturnLoggerPmd_S::set_ret(bool value) {
  set_has_ret();
  ret_ = value;
  // @@protoc_insertion_point(field_set:Pmd.StartUpLoggerReturnLoggerPmd_S.ret)
}

// optional string retdesc = 2;
inline bool StartUpLoggerReturnLoggerPmd_S::has_retdesc() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void StartUpLoggerReturnLoggerPmd_S::set_has_retdesc() {
  _has_bits_[0] |= 0x00000002u;
}
inline void StartUpLoggerReturnLoggerPmd_S::clear_has_retdesc() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void StartUpLoggerReturnLoggerPmd_S::clear_retdesc() {
  if (retdesc_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    retdesc_->clear();
  }
  clear_has_retdesc();
}
inline const ::std::string& StartUpLoggerReturnLoggerPmd_S::retdesc() const {
  // @@protoc_insertion_point(field_get:Pmd.StartUpLoggerReturnLoggerPmd_S.retdesc)
  return *retdesc_;
}
inline void StartUpLoggerReturnLoggerPmd_S::set_retdesc(const ::std::string& value) {
  set_has_retdesc();
  if (retdesc_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    retdesc_ = new ::std::string;
  }
  retdesc_->assign(value);
  // @@protoc_insertion_point(field_set:Pmd.StartUpLoggerReturnLoggerPmd_S.retdesc)
}
inline void StartUpLoggerReturnLoggerPmd_S::set_retdesc(const char* value) {
  set_has_retdesc();
  if (retdesc_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    retdesc_ = new ::std::string;
  }
  retdesc_->assign(value);
  // @@protoc_insertion_point(field_set_char:Pmd.StartUpLoggerReturnLoggerPmd_S.retdesc)
}
inline void StartUpLoggerReturnLoggerPmd_S::set_retdesc(const char* value, size_t size) {
  set_has_retdesc();
  if (retdesc_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    retdesc_ = new ::std::string;
  }
  retdesc_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Pmd.StartUpLoggerReturnLoggerPmd_S.retdesc)
}
inline ::std::string* StartUpLoggerReturnLoggerPmd_S::mutable_retdesc() {
  set_has_retdesc();
  if (retdesc_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    retdesc_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Pmd.StartUpLoggerReturnLoggerPmd_S.retdesc)
  return retdesc_;
}
inline ::std::string* StartUpLoggerReturnLoggerPmd_S::release_retdesc() {
  clear_has_retdesc();
  if (retdesc_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = retdesc_;
    retdesc_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void StartUpLoggerReturnLoggerPmd_S::set_allocated_retdesc(::std::string* retdesc) {
  if (retdesc_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete retdesc_;
  }
  if (retdesc) {
    set_has_retdesc();
    retdesc_ = retdesc;
  } else {
    clear_has_retdesc();
    retdesc_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Pmd.StartUpLoggerReturnLoggerPmd_S.retdesc)
}

// -------------------------------------------------------------------

// LineInfo

// optional uint64 id = 1;
inline bool LineInfo::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LineInfo::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LineInfo::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LineInfo::clear_id() {
  id_ = GOOGLE_ULONGLONG(0);
  clear_has_id();
}
inline ::google::protobuf::uint64 LineInfo::id() const {
  // @@protoc_insertion_point(field_get:Pmd.LineInfo.id)
  return id_;
}
inline void LineInfo::set_id(::google::protobuf::uint64 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:Pmd.LineInfo.id)
}

// optional string name = 2;
inline bool LineInfo::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LineInfo::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LineInfo::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LineInfo::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& LineInfo::name() const {
  // @@protoc_insertion_point(field_get:Pmd.LineInfo.name)
  return *name_;
}
inline void LineInfo::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:Pmd.LineInfo.name)
}
inline void LineInfo::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:Pmd.LineInfo.name)
}
inline void LineInfo::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Pmd.LineInfo.name)
}
inline ::std::string* LineInfo::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Pmd.LineInfo.name)
  return name_;
}
inline ::std::string* LineInfo::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void LineInfo::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Pmd.LineInfo.name)
}

// optional string classname = 3;
inline bool LineInfo::has_classname() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LineInfo::set_has_classname() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LineInfo::clear_has_classname() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LineInfo::clear_classname() {
  if (classname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    classname_->clear();
  }
  clear_has_classname();
}
inline const ::std::string& LineInfo::classname() const {
  // @@protoc_insertion_point(field_get:Pmd.LineInfo.classname)
  return *classname_;
}
inline void LineInfo::set_classname(const ::std::string& value) {
  set_has_classname();
  if (classname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    classname_ = new ::std::string;
  }
  classname_->assign(value);
  // @@protoc_insertion_point(field_set:Pmd.LineInfo.classname)
}
inline void LineInfo::set_classname(const char* value) {
  set_has_classname();
  if (classname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    classname_ = new ::std::string;
  }
  classname_->assign(value);
  // @@protoc_insertion_point(field_set_char:Pmd.LineInfo.classname)
}
inline void LineInfo::set_classname(const char* value, size_t size) {
  set_has_classname();
  if (classname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    classname_ = new ::std::string;
  }
  classname_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Pmd.LineInfo.classname)
}
inline ::std::string* LineInfo::mutable_classname() {
  set_has_classname();
  if (classname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    classname_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Pmd.LineInfo.classname)
  return classname_;
}
inline ::std::string* LineInfo::release_classname() {
  clear_has_classname();
  if (classname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = classname_;
    classname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void LineInfo::set_allocated_classname(::std::string* classname) {
  if (classname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete classname_;
  }
  if (classname) {
    set_has_classname();
    classname_ = classname;
  } else {
    clear_has_classname();
    classname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Pmd.LineInfo.classname)
}

// optional string servername = 4;
inline bool LineInfo::has_servername() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LineInfo::set_has_servername() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LineInfo::clear_has_servername() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LineInfo::clear_servername() {
  if (servername_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    servername_->clear();
  }
  clear_has_servername();
}
inline const ::std::string& LineInfo::servername() const {
  // @@protoc_insertion_point(field_get:Pmd.LineInfo.servername)
  return *servername_;
}
inline void LineInfo::set_servername(const ::std::string& value) {
  set_has_servername();
  if (servername_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    servername_ = new ::std::string;
  }
  servername_->assign(value);
  // @@protoc_insertion_point(field_set:Pmd.LineInfo.servername)
}
inline void LineInfo::set_servername(const char* value) {
  set_has_servername();
  if (servername_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    servername_ = new ::std::string;
  }
  servername_->assign(value);
  // @@protoc_insertion_point(field_set_char:Pmd.LineInfo.servername)
}
inline void LineInfo::set_servername(const char* value, size_t size) {
  set_has_servername();
  if (servername_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    servername_ = new ::std::string;
  }
  servername_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Pmd.LineInfo.servername)
}
inline ::std::string* LineInfo::mutable_servername() {
  set_has_servername();
  if (servername_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    servername_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Pmd.LineInfo.servername)
  return servername_;
}
inline ::std::string* LineInfo::release_servername() {
  clear_has_servername();
  if (servername_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = servername_;
    servername_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void LineInfo::set_allocated_servername(::std::string* servername) {
  if (servername_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete servername_;
  }
  if (servername) {
    set_has_servername();
    servername_ = servername;
  } else {
    clear_has_servername();
    servername_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Pmd.LineInfo.servername)
}

// optional uint32 level = 5;
inline bool LineInfo::has_level() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void LineInfo::set_has_level() {
  _has_bits_[0] |= 0x00000010u;
}
inline void LineInfo::clear_has_level() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void LineInfo::clear_level() {
  level_ = 0u;
  clear_has_level();
}
inline ::google::protobuf::uint32 LineInfo::level() const {
  // @@protoc_insertion_point(field_get:Pmd.LineInfo.level)
  return level_;
}
inline void LineInfo::set_level(::google::protobuf::uint32 value) {
  set_has_level();
  level_ = value;
  // @@protoc_insertion_point(field_set:Pmd.LineInfo.level)
}

// optional uint32 timestamp = 6;
inline bool LineInfo::has_timestamp() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void LineInfo::set_has_timestamp() {
  _has_bits_[0] |= 0x00000020u;
}
inline void LineInfo::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void LineInfo::clear_timestamp() {
  timestamp_ = 0u;
  clear_has_timestamp();
}
inline ::google::protobuf::uint32 LineInfo::timestamp() const {
  // @@protoc_insertion_point(field_get:Pmd.LineInfo.timestamp)
  return timestamp_;
}
inline void LineInfo::set_timestamp(::google::protobuf::uint32 value) {
  set_has_timestamp();
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:Pmd.LineInfo.timestamp)
}

// optional string log = 7;
inline bool LineInfo::has_log() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void LineInfo::set_has_log() {
  _has_bits_[0] |= 0x00000040u;
}
inline void LineInfo::clear_has_log() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void LineInfo::clear_log() {
  if (log_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    log_->clear();
  }
  clear_has_log();
}
inline const ::std::string& LineInfo::log() const {
  // @@protoc_insertion_point(field_get:Pmd.LineInfo.log)
  return *log_;
}
inline void LineInfo::set_log(const ::std::string& value) {
  set_has_log();
  if (log_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    log_ = new ::std::string;
  }
  log_->assign(value);
  // @@protoc_insertion_point(field_set:Pmd.LineInfo.log)
}
inline void LineInfo::set_log(const char* value) {
  set_has_log();
  if (log_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    log_ = new ::std::string;
  }
  log_->assign(value);
  // @@protoc_insertion_point(field_set_char:Pmd.LineInfo.log)
}
inline void LineInfo::set_log(const char* value, size_t size) {
  set_has_log();
  if (log_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    log_ = new ::std::string;
  }
  log_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Pmd.LineInfo.log)
}
inline ::std::string* LineInfo::mutable_log() {
  set_has_log();
  if (log_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    log_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Pmd.LineInfo.log)
  return log_;
}
inline ::std::string* LineInfo::release_log() {
  clear_has_log();
  if (log_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = log_;
    log_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void LineInfo::set_allocated_log(::std::string* log) {
  if (log_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete log_;
  }
  if (log) {
    set_has_log();
    log_ = log;
  } else {
    clear_has_log();
    log_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Pmd.LineInfo.log)
}

// -------------------------------------------------------------------

// GameZoneNewLineRequestLoggerPmd_C

// optional .Pmd.GameZoneInfo gamezone = 1;
inline bool GameZoneNewLineRequestLoggerPmd_C::has_gamezone() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GameZoneNewLineRequestLoggerPmd_C::set_has_gamezone() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GameZoneNewLineRequestLoggerPmd_C::clear_has_gamezone() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GameZoneNewLineRequestLoggerPmd_C::clear_gamezone() {
  if (gamezone_ != NULL) gamezone_->::Pmd::GameZoneInfo::Clear();
  clear_has_gamezone();
}
inline const ::Pmd::GameZoneInfo& GameZoneNewLineRequestLoggerPmd_C::gamezone() const {
  // @@protoc_insertion_point(field_get:Pmd.GameZoneNewLineRequestLoggerPmd_C.gamezone)
  return gamezone_ != NULL ? *gamezone_ : *default_instance_->gamezone_;
}
inline ::Pmd::GameZoneInfo* GameZoneNewLineRequestLoggerPmd_C::mutable_gamezone() {
  set_has_gamezone();
  if (gamezone_ == NULL) gamezone_ = new ::Pmd::GameZoneInfo;
  // @@protoc_insertion_point(field_mutable:Pmd.GameZoneNewLineRequestLoggerPmd_C.gamezone)
  return gamezone_;
}
inline ::Pmd::GameZoneInfo* GameZoneNewLineRequestLoggerPmd_C::release_gamezone() {
  clear_has_gamezone();
  ::Pmd::GameZoneInfo* temp = gamezone_;
  gamezone_ = NULL;
  return temp;
}
inline void GameZoneNewLineRequestLoggerPmd_C::set_allocated_gamezone(::Pmd::GameZoneInfo* gamezone) {
  delete gamezone_;
  gamezone_ = gamezone;
  if (gamezone) {
    set_has_gamezone();
  } else {
    clear_has_gamezone();
  }
  // @@protoc_insertion_point(field_set_allocated:Pmd.GameZoneNewLineRequestLoggerPmd_C.gamezone)
}

// optional .Pmd.LineInfo filter = 2;
inline bool GameZoneNewLineRequestLoggerPmd_C::has_filter() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GameZoneNewLineRequestLoggerPmd_C::set_has_filter() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GameZoneNewLineRequestLoggerPmd_C::clear_has_filter() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GameZoneNewLineRequestLoggerPmd_C::clear_filter() {
  if (filter_ != NULL) filter_->::Pmd::LineInfo::Clear();
  clear_has_filter();
}
inline const ::Pmd::LineInfo& GameZoneNewLineRequestLoggerPmd_C::filter() const {
  // @@protoc_insertion_point(field_get:Pmd.GameZoneNewLineRequestLoggerPmd_C.filter)
  return filter_ != NULL ? *filter_ : *default_instance_->filter_;
}
inline ::Pmd::LineInfo* GameZoneNewLineRequestLoggerPmd_C::mutable_filter() {
  set_has_filter();
  if (filter_ == NULL) filter_ = new ::Pmd::LineInfo;
  // @@protoc_insertion_point(field_mutable:Pmd.GameZoneNewLineRequestLoggerPmd_C.filter)
  return filter_;
}
inline ::Pmd::LineInfo* GameZoneNewLineRequestLoggerPmd_C::release_filter() {
  clear_has_filter();
  ::Pmd::LineInfo* temp = filter_;
  filter_ = NULL;
  return temp;
}
inline void GameZoneNewLineRequestLoggerPmd_C::set_allocated_filter(::Pmd::LineInfo* filter) {
  delete filter_;
  filter_ = filter;
  if (filter) {
    set_has_filter();
  } else {
    clear_has_filter();
  }
  // @@protoc_insertion_point(field_set_allocated:Pmd.GameZoneNewLineRequestLoggerPmd_C.filter)
}

// -------------------------------------------------------------------

// GameZoneNewLineWriteLoggerPmd_S

// optional .Pmd.LineInfo line = 1;
inline bool GameZoneNewLineWriteLoggerPmd_S::has_line() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GameZoneNewLineWriteLoggerPmd_S::set_has_line() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GameZoneNewLineWriteLoggerPmd_S::clear_has_line() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GameZoneNewLineWriteLoggerPmd_S::clear_line() {
  if (line_ != NULL) line_->::Pmd::LineInfo::Clear();
  clear_has_line();
}
inline const ::Pmd::LineInfo& GameZoneNewLineWriteLoggerPmd_S::line() const {
  // @@protoc_insertion_point(field_get:Pmd.GameZoneNewLineWriteLoggerPmd_S.line)
  return line_ != NULL ? *line_ : *default_instance_->line_;
}
inline ::Pmd::LineInfo* GameZoneNewLineWriteLoggerPmd_S::mutable_line() {
  set_has_line();
  if (line_ == NULL) line_ = new ::Pmd::LineInfo;
  // @@protoc_insertion_point(field_mutable:Pmd.GameZoneNewLineWriteLoggerPmd_S.line)
  return line_;
}
inline ::Pmd::LineInfo* GameZoneNewLineWriteLoggerPmd_S::release_line() {
  clear_has_line();
  ::Pmd::LineInfo* temp = line_;
  line_ = NULL;
  return temp;
}
inline void GameZoneNewLineWriteLoggerPmd_S::set_allocated_line(::Pmd::LineInfo* line) {
  delete line_;
  line_ = line;
  if (line) {
    set_has_line();
  } else {
    clear_has_line();
  }
  // @@protoc_insertion_point(field_set_allocated:Pmd.GameZoneNewLineWriteLoggerPmd_S.line)
}

// -------------------------------------------------------------------

// GameZoneHistoryLineRequestLoggerPmd_C

// optional .Pmd.GameZoneInfo gamezone = 1;
inline bool GameZoneHistoryLineRequestLoggerPmd_C::has_gamezone() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GameZoneHistoryLineRequestLoggerPmd_C::set_has_gamezone() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GameZoneHistoryLineRequestLoggerPmd_C::clear_has_gamezone() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GameZoneHistoryLineRequestLoggerPmd_C::clear_gamezone() {
  if (gamezone_ != NULL) gamezone_->::Pmd::GameZoneInfo::Clear();
  clear_has_gamezone();
}
inline const ::Pmd::GameZoneInfo& GameZoneHistoryLineRequestLoggerPmd_C::gamezone() const {
  // @@protoc_insertion_point(field_get:Pmd.GameZoneHistoryLineRequestLoggerPmd_C.gamezone)
  return gamezone_ != NULL ? *gamezone_ : *default_instance_->gamezone_;
}
inline ::Pmd::GameZoneInfo* GameZoneHistoryLineRequestLoggerPmd_C::mutable_gamezone() {
  set_has_gamezone();
  if (gamezone_ == NULL) gamezone_ = new ::Pmd::GameZoneInfo;
  // @@protoc_insertion_point(field_mutable:Pmd.GameZoneHistoryLineRequestLoggerPmd_C.gamezone)
  return gamezone_;
}
inline ::Pmd::GameZoneInfo* GameZoneHistoryLineRequestLoggerPmd_C::release_gamezone() {
  clear_has_gamezone();
  ::Pmd::GameZoneInfo* temp = gamezone_;
  gamezone_ = NULL;
  return temp;
}
inline void GameZoneHistoryLineRequestLoggerPmd_C::set_allocated_gamezone(::Pmd::GameZoneInfo* gamezone) {
  delete gamezone_;
  gamezone_ = gamezone;
  if (gamezone) {
    set_has_gamezone();
  } else {
    clear_has_gamezone();
  }
  // @@protoc_insertion_point(field_set_allocated:Pmd.GameZoneHistoryLineRequestLoggerPmd_C.gamezone)
}

// optional .Pmd.LineInfo filter = 2;
inline bool GameZoneHistoryLineRequestLoggerPmd_C::has_filter() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GameZoneHistoryLineRequestLoggerPmd_C::set_has_filter() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GameZoneHistoryLineRequestLoggerPmd_C::clear_has_filter() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GameZoneHistoryLineRequestLoggerPmd_C::clear_filter() {
  if (filter_ != NULL) filter_->::Pmd::LineInfo::Clear();
  clear_has_filter();
}
inline const ::Pmd::LineInfo& GameZoneHistoryLineRequestLoggerPmd_C::filter() const {
  // @@protoc_insertion_point(field_get:Pmd.GameZoneHistoryLineRequestLoggerPmd_C.filter)
  return filter_ != NULL ? *filter_ : *default_instance_->filter_;
}
inline ::Pmd::LineInfo* GameZoneHistoryLineRequestLoggerPmd_C::mutable_filter() {
  set_has_filter();
  if (filter_ == NULL) filter_ = new ::Pmd::LineInfo;
  // @@protoc_insertion_point(field_mutable:Pmd.GameZoneHistoryLineRequestLoggerPmd_C.filter)
  return filter_;
}
inline ::Pmd::LineInfo* GameZoneHistoryLineRequestLoggerPmd_C::release_filter() {
  clear_has_filter();
  ::Pmd::LineInfo* temp = filter_;
  filter_ = NULL;
  return temp;
}
inline void GameZoneHistoryLineRequestLoggerPmd_C::set_allocated_filter(::Pmd::LineInfo* filter) {
  delete filter_;
  filter_ = filter;
  if (filter) {
    set_has_filter();
  } else {
    clear_has_filter();
  }
  // @@protoc_insertion_point(field_set_allocated:Pmd.GameZoneHistoryLineRequestLoggerPmd_C.filter)
}

// -------------------------------------------------------------------

// GameZoneHistoryLineWriteLoggerPmd_S

// repeated .Pmd.LineInfo linelist = 1;
inline int GameZoneHistoryLineWriteLoggerPmd_S::linelist_size() const {
  return linelist_.size();
}
inline void GameZoneHistoryLineWriteLoggerPmd_S::clear_linelist() {
  linelist_.Clear();
}
inline const ::Pmd::LineInfo& GameZoneHistoryLineWriteLoggerPmd_S::linelist(int index) const {
  // @@protoc_insertion_point(field_get:Pmd.GameZoneHistoryLineWriteLoggerPmd_S.linelist)
  return linelist_.Get(index);
}
inline ::Pmd::LineInfo* GameZoneHistoryLineWriteLoggerPmd_S::mutable_linelist(int index) {
  // @@protoc_insertion_point(field_mutable:Pmd.GameZoneHistoryLineWriteLoggerPmd_S.linelist)
  return linelist_.Mutable(index);
}
inline ::Pmd::LineInfo* GameZoneHistoryLineWriteLoggerPmd_S::add_linelist() {
  // @@protoc_insertion_point(field_add:Pmd.GameZoneHistoryLineWriteLoggerPmd_S.linelist)
  return linelist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Pmd::LineInfo >&
GameZoneHistoryLineWriteLoggerPmd_S::linelist() const {
  // @@protoc_insertion_point(field_list:Pmd.GameZoneHistoryLineWriteLoggerPmd_S.linelist)
  return linelist_;
}
inline ::google::protobuf::RepeatedPtrField< ::Pmd::LineInfo >*
GameZoneHistoryLineWriteLoggerPmd_S::mutable_linelist() {
  // @@protoc_insertion_point(field_mutable_list:Pmd.GameZoneHistoryLineWriteLoggerPmd_S.linelist)
  return &linelist_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace Pmd

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::Pmd::Logger_Param> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Pmd::Logger_Param>() {
  return ::Pmd::Logger_Param_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_loggercommand_2eproto__INCLUDED
